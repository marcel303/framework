include engine/ShaderPS.txt
include engine/builtin-hq-common.txt

shader_in vec3 v_edgePlane1;
shader_in vec3 v_edgePlane2;
shader_in vec3 v_edgePlane3;
shader_in vec3 v_edgePlane4;
shader_in float v_radius;
shader_in vec4 v_color;

float computeDistance(vec2 p)
{
	float d1 = dot(v_edgePlane1, vec3(p, 1.0));
	float d2 = dot(v_edgePlane2, vec3(p, 1.0));
	float d3 = dot(v_edgePlane3, vec3(p, 1.0));
	float d4 = dot(v_edgePlane4, vec3(p, 1.0));
	
	int i1 = 0;
	float da1 = d1;
	if (d2 < da1) { da1 = d2; i1 = 1; }
	if (d3 < da1) { da1 = d3; i1 = 2; }
	if (d4 < da1) { da1 = d4; i1 = 3; }

	float da2;
	if (i1 == 0) da2 = d2;
	if (i1 == 1) da2 = d3;
	if (i1 == 2) da2 = d4;
	if (i1 == 3) da2 = d1;

	if (i1 != 0 && d1 < da2) da2 = d1;
	if (i1 != 1 && d2 < da2) da2 = d2;
	if (i1 != 2 && d3 < da2) da2 = d3;
	if (i1 != 3 && d4 < da2) da2 = d4;

	float d;

	if (da1 < 0.0 && da2 < 0.0)
		d = v_radius - sqrt(da1 * da1 + da2 * da2);
	else
		d = min(da1, da2) + v_radius;
	
	return d;
}

float distanceFade(float distance)
{
	return clamp(distance + 0.5, 0.0, 1.0);
}

void main()
{
	float v = 0.0;
	
	float d = computeDistance(v_p);
	
	if (d > 0.5 && enableOptimizations)
	{
		v = 1.0;
	}
	else
	{
		v = sampleDistanceFunction(v_p);
	}

	vec4 color = hqColor(v, v_color);
	
	shader_fragColor = color;
}
