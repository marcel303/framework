/*
	Copyright (C) 2020 Marcel Smit
	marcel303@gmail.com
	https://www.facebook.com/marcel.smit981

	Permission is hereby granted, free of charge, to any person
	obtaining a copy of this software and associated documentation
	files (the "Software"), to deal in the Software without
	restriction, including without limitation the rights to use,
	copy, modify, merge, publish, distribute, sublicense, and/or
	sell copies of the Software, and to permit persons to whom the
	Software is furnished to do so, subject to the following
	conditions:

	The above copyright notice and this permission notice shall be
	included in all copies or substantial portions of the Software.

	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
	EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
	OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
	NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
	HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
	WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
	FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
	OTHER DEALINGS IN THE SOFTWARE.
*/

#pragma once

#include "audioThreading.h"
#include "audioTypes.h"
#include "limiter.h"

struct AudioSource;

// todo : see if it's possible to write documentation outside of the context of the code
//        .. using Doxygen

// todo : document more things. documenting code as a way to make refinements

/**
Audio voices represent the endpoints being asked to produce audio data inside the audio graph system.
Audio voices produce a single channel (mono) audio buffer, which may be mixed in various ways, depending
on the type of voice manager in use, and settings such as the speaker panning configuration set on the voice.

Different voice managers may implement a different AudioVoice implementation, and may or may not apply all
of the settings set on a voice. A spatial audio implementation for instance may ignore the speaker panning
set on the voice. Although this information is very useful in a more traditional stereo panning implementation.

Voices are allocated and freed using a AudioVoiceManager. At the time of writing, two voice manager
implementations exist: AudioVoiceManagerBasic and AudioVoiceManager4D. These voice managers both
implement a AudioVoiceManager::generateAudio method, which asks from them to generate multi-channel audio.

Multi-channel audio is generated by iterating over all of the voices known to the voice manager. Audio voices are
asked to produce an audio buffer. This buffer is then mixed depending on the implementation of the voice manager
and fields set inside the voice, such as speaker panning and channel index.

Shared features of AudioVoice are: type, speaker panning, ramping (smooth activation and deactivation of a voice), gain and a limiter.

Usage example:
```cpp

AudioMutex mutex;
mutex.init();

AudioVoiceManagerBasic voiceMgr;
voiceMgr.init(&mutex, 256);
voiceMgr.outputStereo = true;

const PcmData * pcmData = getPcmData("test.wav");
 
AudioSourcePcm source;
source.init(pcmData, 0);

AudioVoice * voice = nullptr;
if (voiceMgr.allocVoice(voice, &source, "My Voice", true, 0.f, 1.f))
{
 	printf("successfully created a voice!\n");
}

for (int i = 0; i < 10; ++i)
{
	float samples[256 * 2];
	voiceMgr.generateAudio(samples, 256, 2);
}
```
*/
struct AudioVoice
{
	enum Type
	{
		kType_Basic,  ///< A voice allocated by AudioVoiceManagerBasic.
		kType_4DSOUND ///< A voice allocated by AudioVoiceManager4D.
	};

	/**
	 * The speaker panning configuration. This setting only applies to voice managers capable of stereo output.
	 * The speaker panning configuration is taking into account when mixing voices. A voice may indicate
	 * it should be panned both left and right, left or right only, or output to a specific channel.
	 */
	enum Speaker
	{
		kSpeaker_None,         ///< Speaker type not set. Use the default mixing behavior of the voice manager.
		kSpeaker_LeftAndRight, ///< Pan the voice to both the left and right, in case of stereo output.
		kSpeaker_Left,         ///< Pan the voice to the left side only, in case of stereo output.
		kSpeaker_Right,        ///< Pan the voice to the right side only, in case of stereo output.
		kSpeaker_Channel       ///< Mix the voice to a specific output channel.
	};
	
	struct RampInfo
	{
		bool ramp;            ///< Whether the ramp should go up (true) or down (false).
		float rampValue;      ///< The current ramp value (between 0.0 and 1.0).
		float rampDelay;      ///< The time (in seconds) of delay before the actual ramp occurs.
		bool rampDelayIsZero; ///< True when the ramp delay is, or has reached, zero.
		float rampTime;       ///< The time (in seconds) for the ramp to finish.
		bool isRamped;        ///< True if done ramping up or down.
		bool hasRamped;       ///< True if the ramp up or down completed during the last update.
		
		RampInfo()
			: ramp(true)
			, rampValue(1.f)
			, rampDelay(0.f)
			, rampDelayIsZero(false)
			, rampTime(0.f)
			, isRamped(true)
			, hasRamped(false)
		{
		}
		
		/**
		 * Perform a ramp up, with the given delay and duration.
		 */
		void rampUp(const float delay, const float duration)
		{
			ramp = true;
			rampDelay = delay;
			rampDelayIsZero = delay == 0.f;
			rampTime = duration;
		}
		
		/**
		 * Perform a ramp down, with the given delay and duration.
		 */
		void rampDown(const float delay, const float duration)
		{
			ramp = false;
			rampDelay = delay;
			rampDelayIsZero = delay == 0.f;
			rampTime = duration;
		}
	};
	
	int channelIndex;     ///< The output channel to mix this voice to. Channel indices start at zero. Typically in a stereo output setting, channel 0 maps to the left speaker, and channel 1 to the right. In a multi-speaker setup, the channel index maps to the output channel on the audio interface. In a spatial audio setup, the channel index is interpreted by the spatial audio system using rules of its own.

	Type type;            ///< The type of voice (basic or 4D). The type of voice returned by VoiceManager::allocVoice depends on the actual implementation of the voice manager. Audio voice nodes may wish to inspect the type and set implementation specific details for the voice, such as spatial parameters if the type is AudioVoice4D.
	
	Speaker speaker;      ///< The speaker to pan to. Used by stereo mixing algorithms to pan the voice.
	
	AudioSource * source; ///< The audio source. The audio source generates the (mono) audio buffer for this voice. When used in the context of audiograph, the source usually points to a voice node, which gets it signal from the graph connected to it. In the context of other applications, this could be anything, from a PCM file to a custom generator.
	
	float gain;           ///< The gain to apply to the signal generated by the audio source, usually between 0.0 and 1.0, but could be anything.
	
	RampInfo rampInfo;    ///< Ramping info. Keeps track of the current ramping state. Ramping info is updated and applied by the voice manager when it is asked to perform mixing.
	
	Limiter limiter;      ///< Limiter for protecting against loud sounds. The limiter keeps the signal within the -/+ max gain range (which is specified when applyLimiter is called), applying a dynamic scaling factor when the signal becomes too loud.
	
	AudioVoice * next;    ///< Next voice in the list of voices maintained by the voice manager. Note that we use a intrusive linked list implementation. This is ok since each voice is allocated by, and belongs to, a single voice manager.
	
	AudioVoice(const Type _type = kType_Basic)
		: channelIndex(-1)
		, type(_type)
		, speaker(kSpeaker_None)
		, source(nullptr)
		, gain(1.f)
		, rampInfo()
		, limiter()
		, next(nullptr)
	{
	}
	
	/**
	 * Applies ramping (fade in or fade out) to the given signal based on the ramping state of the voice.
	 * @param samples The samples to apply ramping to.
	 * @param numSamples The size of the samples array.
	 * @param durationInSamples The duration of the ramp in discrete samples. Note you will have to convert the ramp duration inside the voice's rampInfo member to a discrete number of samples yourself by multiplying the duration with the current sample rate.
	 * @param updateRamping Whether to update the ramping state within the rampInfo member. If false, this method can be called multiple times without side effects. This is useful for instance when you want to generate a signal for visualization purposes, without affecting the outputted sound.
	 */
	void applyRamping(float * __restrict samples, const int numSamples, const int durationInSamples, const bool updateRamping);
	
	/**
	 * Applies the limiter.
	 * @param samples The samples to apply the limiter to.
	 * @param numSamples The size of the samples array.
	 * @param maxGain The maximum gain. Values with a magnitude larger than this will be scaled down by the limiter until they are within the maxGain range.
	 */
	void applyLimiter(float * __restrict samples, const int numSamples, const float maxGain);
};

struct AudioVoiceManager
{
	enum Type
	{
		kType_Basic,  ///< AudioVoiceManagerBasic.
		kType_4DSOUND ///< AudioVoiceManager4D.
	};
	
	/**
	 * The output mode, passed to generateAudio. generateAudio is a shared method of AudioVoiceManager,
	 * which provides a basic mixer implementation that supports mono and stereo panning and multi-channel output.
	 */
	enum OutputMode
	{
		kOutputMode_Mono,        ///< Mix voices down to a mono signal.
		kOutputMode_Stereo,      ///< Mix voices down to a stereo signal.
		kOutputMode_MultiChannel ///< Mix voices to a mult-channel output.
	};
	
	const Type type; ///< The type of the AudioVoiceManager implementation.
	
	AudioVoiceManager(const Type _type);
    virtual ~AudioVoiceManager() { } ///< Here to add a virtual destructor to AudioVoiceManager.
	
	/**
	 * generateAudio provides a shared mixer implementation, which is capable of mixing
	 * voices down to a mono or stereo signal, or to a multi-channel output.
	 * Note this method is NOT thread safe. You will have to lock the audio mutex (when applicable) yourself before calling this method.
	 * @param voices The voices to mix.
	 * @param numVoices The size of the voices array.
	 * @param samples The output samples.
	 * @param numSamples The number of output sample to produce.
	 * @param numChannels The number of output channels to produce. The total number of channels is numSamples x numChannels.
	 * @param doLimiting True if the limiter should be applied. False to generate a raw signal.
	 * @param limiterPeak The peak gain value to use when the limiter is applied.
	 * @param updateRamping True when the ramping state should be updated. False to run this method without side effects.
	 * @param globalGain The global gain to apply to each voice.
	 * @param outputMode The output mode (mono, stereo or multi-channel).
	 * @param interleaved True when the stereo or multi-channel output should be written in an interleaved fashion. Interleaved means that the values for channel 0, 1, 2 etc will be packed next to each other inside the samples array. When false, the channels are output in a planar fashion. Which means first numSamples for channel 0 are output, followed by numSamples for channel 1, etc.
	 */
	static void generateAudio(
		AudioVoice ** voices,
		const int numVoices,
		float * __restrict samples, const int numSamples, const int numChannels,
		const bool doLimiting,
		const float limiterPeak,
		const bool updateRamping,
		const float globalGain,
		const OutputMode outputMode,
		const bool interleaved);
	
	/**
	 * Allocates a voice and registers it with the voice manager.
	 * Note this method is thread safe.
	 * @param voice A pointer to the newly allocated voice.
	 * @param source The audio source to use for the voice.
	 * @param name The name of the voice, for debugging and visualization purposes.
	 * @param doRamping True if the voice should do a ramp (up) on start. If false, there may be audible clicks when the voices becomes active.
	 * @param rampDelay The delay (in seconds) for the ramp to begin. When coding against the 4DSOUND engine this is useful, to ensure OSC parameters are sent to the spatialization engine first. If audible sound arrive before the engine's DSP is set to the right values, there may be unexpected sound artefacts when the voice becomes active.
	 * @param rampTime The duration (in seconds) of the ramp.
	 * @param channelIndex The channel index for the source. Should be -1 unless the voice should explicitly be mixed to the given output channel.
	 */
	virtual bool allocVoice(AudioVoice *& voice, AudioSource * source, const char * name, const bool doRamping, const float rampDelay, const float rampTime, const int channelIndex = -1) = 0;
	
	/**
	 * Frees a voice and removes its registrattion from the voice manager.
	 * Note this method is thread safe.
	 * @param voice The voice to free. Note that voice will be set to nullptr when freed.
	 */
	virtual void freeVoice(AudioVoice *& voice) = 0;
	
	/**
	 * Returns the number of voices by traversing the list of voices and counting them.
	 * Note this method is thread safe.
	 * @return The number of voices registered with the voice manager.
	*/
	virtual int calculateNumVoices() const = 0;
	
	/**
	 * Interface method implemented by a voice manager, which generates audio from voices. Use it to output audio.
	 * Note this method is thread safe.
	 * @param samples The array of samples to fill. Note that samples will always be set to zero first, in case there are no voices mixed to a channel.
	 * @param numSamples The number of samples to generate.
	 * @param numChannels The number of output channels. The total number of samples is numSamples x numChannels.
	 */
	virtual void generateAudio(float * __restrict samples, const int numSamples, const int numChannels) = 0;
};

/**
 * The basic voice manager uses a basic mixer implementation to mix down to stereo or to mix to a multi-channel output.
 */
struct AudioVoiceManagerBasic : AudioVoiceManager
{
private:
	AudioMutexBase * audioMutex;
	
	int numDynamicChannels; ///< The number of dynamic channels, for voices wishing to be allocated to a dynamic channel index.
	AudioVoice * firstVoice; ///< First voice in the list of registered voices.
	
public:
	bool outputStereo; ///< When true, the voice manager will down mix to stereo. Otherwise, multi-channel mixing is used.
	
public:
	AudioVoiceManagerBasic();
	
	void init(AudioMutexBase * audioMutex, const int numDynamicChannels);
	void shut();
	
	virtual bool allocVoice(AudioVoice *& voice, AudioSource * source, const char * name, const bool doRamping, const float rampDelay, const float rampTime, const int channelIndex = -1) override;
	virtual void freeVoice(AudioVoice *& voice) override;
	virtual int calculateNumVoices() const override;
	
	virtual void generateAudio(float * __restrict samples, const int numSamples, const int numChannels) override;
	
	int calculateNumDynamicChannelsUsed() const; ///< Calculates the number of dynamic channels in use, by traversing the list of voices and checking their channel allocations.
	int getNumDynamicChannels() const; ///< Returns the number of dynamic channels set on init.
	
private:
	void updateDynamicChannelIndices(); ///< Assigns channel indices for voices requesting a dynamic channel index.
};
