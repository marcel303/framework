/*
Copyright (C) 2017 Marcel Smit
marcel303@gmail.com
https://www.facebook.com/marcel.smit981

Permission is hereby granted, free of charge, to any person
obtaining a copy of this software and associated documentation
files (the "Software"), to deal in the Software without
restriction, including without limitation the rights to use,
copy, modify, merge, publish, distribute, sublicense, and/or
sell copies of the Software, and to permit persons to whom the
Software is furnished to do so, subject to the following
conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
OTHER DEALINGS IN THE SOFTWARE.
*/

#include "audioGraph.h"
#include "audioGraphManager.h"
#include "soundmix.h" // AudioSource, audioBufferSetZero
#include "StringEx.h"
#include "vfxChannelZipper.h"
#include "vfxNodeAudioGraphPoly.h"

#include "framework.h"

#include "Timer.h"

void VoiceMgr_VoiceGroup::NullSource::generate(SAMPLE_ALIGN16 float * __restrict samples, const int numSamples)
{
	audioBufferSetZero(samples, numSamples);
}

bool VoiceMgr_VoiceGroup::allocVoice(AudioVoice *& voice, AudioSource * source, const char * name, const bool doRamping, const float rampDelay, const float rampTime, const int channelIndex)
{
	const bool result = voiceMgr->allocVoice(
		voice,
		muted.load()
			? &nullSource
			: source,
		name,
		doRamping,
		rampDelay,
		rampTime);
	
	if (voice != nullptr)
	{
		VoiceInfo voiceInfo;
		voiceInfo.voice = voice;
		voiceInfo.source = source;
		
		graphMgr->lockAudio();
		{
			voiceInfos.push_back(voiceInfo);
		}
		graphMgr->unlockAudio();
		
		updateVoices();
	}
	
	return result;
}

void VoiceMgr_VoiceGroup::freeVoice(AudioVoice *& voice)
{
	graphMgr->lockAudio();
	{
		for (auto i = voiceInfos.begin(); i != voiceInfos.end(); ++i)
		{
			auto & voiceInfo = *i;
			
			if (voiceInfo.voice == voice)
			{
				voiceInfos.erase(i);
				break;
			}
		}
	}
	graphMgr->unlockAudio();
	
	voiceMgr->freeVoice(voice);
}

int VoiceMgr_VoiceGroup::calculateNumVoices() const
{
	int result;
	
	graphMgr->lockAudio();
	{
		result = voiceInfos.size();
	}
	graphMgr->unlockAudio();
	
	return result;
}

VFX_ENUM_TYPE(audioGraphPolyOutputMode)
{
	elem("mono");
	elem("stereo");
	elem("multichannel");
};

VFX_NODE_TYPE(VfxNodeAudioGraphPoly)
{
	typeName = "audioGraph.poly";
	in("file", "string");
	in("volume", "channel");
	in("polyphony", "int", "-1");
	inEnum("mode", "audioGraphPolyOutputMode");
	in("muted", "bool", "0");
	out("voices", "channel");
}

VfxNodeAudioGraphPoly::VfxNodeAudioGraphPoly()
	: VfxNodeBase()
	, voiceMgr()
	, context(nullptr)
	, instances()
	, currentFilename()
	, voicesData()
	, voicesOutput()
	, history()
	, historyWritePos(0)
	, historySize(0)
{
	resizeSockets(kInput_COUNT, kOutput_COUNT);
	addInput(kInput_Filename, kVfxPlugType_String);
	addInput(kInput_Volume, kVfxPlugType_Channel);
	addInput(kInput_MaxInstances, kVfxPlugType_Int);
	addInput(kInput_OutputMode, kVfxPlugType_Int);
	addInput(kInput_Muted, kVfxPlugType_Bool);
	addOutput(kOutput_Voices, kVfxPlugType_Channel, &voicesOutput);
	
	memset(instances, 0, sizeof(instances));
}

void VfxNodeAudioGraphPoly::init(const GraphNode & node)
{
	auto * audioGraphMgr = g_currentVfxGraph->context->tryGetSystem<AudioGraphManager>();
	auto * audioVoiceMgr = g_currentVfxGraph->context->tryGetSystem<AudioVoiceManager>();
	
	if (audioGraphMgr == nullptr || audioVoiceMgr == nullptr)
	{
		setEditorIssue("missing required audio graph system");
	}
	else
	{
		// we create our own audio graph context, so we can override the voice
		// manager with a proxy voice manager, which sits in between the global
		// audio voice manager set up for the vfx context, and the audio graph
		// instances we create. this allows us to easily tap into the audio
		// signals generated by the voices of our graphs
		
		voiceMgr.init(audioGraphMgr, audioVoiceMgr);
		
		context = audioGraphMgr->createContext(&voiceMgr);
		
		//
		
		const bool muted = getInputBool(kInput_Muted, false);
		
		voiceMgr.setMuted(muted);
	}
}

VfxNodeAudioGraphPoly::~VfxNodeAudioGraphPoly()
{
	auto * audioGraphMgr = g_currentVfxGraph->context->tryGetSystem<AudioGraphManager>();
	
	for (int i = 0; i < kMaxInstances; ++i)
	{
		if (instances[i] != nullptr)
			audioGraphMgr->free(instances[i], false);
	}
	
	if (context != nullptr)
	{
		// note : some of our instances may still be fading out (if they had voices with a fade out time set on them). quite conveniently, freeContext will prune any instances still left fading out that reference our context
		audioGraphMgr->freeContext(context);
	}
}

void VfxNodeAudioGraphPoly::updateDynamicInputs()
{
	AudioGraphInstance * audioGraphInstance = nullptr;
	
	for (int i = 0; i < kMaxInstances; ++i)
	{
		if (instances[i] != nullptr)
		{
			audioGraphInstance = instances[i];
			break;
		}
	}
	
	if (audioGraphInstance == nullptr)
	{
		if (!currentControlValues.empty())
		{
			logDebug("resetting dynamic inputs");
			
			setDynamicInputs(nullptr, 0);
			
			currentControlValues.clear();
		}
	}
	else
	{
	// todo : add dynamic inputs for shared/context scope control values
	
		auto audioGraph = audioGraphInstance->audioGraph;
		
		audioGraph->lockControlValues();
		{
			const auto & controlValues = audioGraph->controlValues;
			
			bool equal = true;
			
			if (equal)
			{
				if (controlValues.size() != currentControlValues.size())
				{
					logDebug("control values size changed. %d -> %d", currentControlValues.size(), controlValues.size());
					equal = false;
				}
			}
			
			if (equal)
			{
				int index = 0;
				
				for (auto & controlValue : controlValues)
				{
					if (controlValue.name != currentControlValues[index])
					{
						logDebug("control values name changed (%d)", index);
						equal = false;
					}
					
					index++;
				}
			}
			
			if (equal == false)
			{
				logDebug("control values changed. updating dynamic inputs");
				
				std::vector<DynamicInput> dynamicInputs;
				dynamicInputs.resize(controlValues.size());
				
				currentControlValues.clear();

				int index = 0;

				for (auto & controlValue : controlValues)
				{
					auto & dynamicInput = dynamicInputs[index];
					
					dynamicInput.name = controlValue.name;
					dynamicInput.type = kVfxPlugType_Channel;
					dynamicInput.defaultValue = String::FormatC("%f", controlValue.defaultX);
					
					currentControlValues.push_back(controlValue.name);
					
					index++;
				}

				if (dynamicInputs.empty())
					setDynamicInputs(nullptr, 0);
				else
					setDynamicInputs(dynamicInputs.data(), dynamicInputs.size());
			}
		}
		audioGraph->unlockControlValues();
	}
}

void VfxNodeAudioGraphPoly::listChannels(const VfxChannel ** channels, const VfxChannel * volume, int & numChannels, const int maxChannels)
{
	numChannels = 0;
	
	if (numChannels < maxChannels)
		channels[numChannels++] = volume;
	
	for (int i = 0; i < dynamicInputs.size(); ++i)
	{
		auto input = tryGetInput(kInput_COUNT + i);
		
		Assert(input != nullptr);
		if (input != nullptr && input->type == kVfxPlugType_Channel)
		{
			const VfxChannel * channel = input->isConnected() ? input->getChannel() : nullptr;
			
			if (numChannels < maxChannels)
				channels[numChannels++] = channel;
		}
	}
}

void VfxNodeAudioGraphPoly::addHistoryElem(const HistoryType type, const float value)
{
	history[historyWritePos].type = type;
	history[historyWritePos].value = value;
	
	historyWritePos = (historyWritePos + 1) % kMaxHistory;
	if (historySize < kMaxHistory)
		historySize++;
}

void VfxNodeAudioGraphPoly::tick(const float dt)
{
	const char * filename = getInputString(kInput_Filename, nullptr);
	const VfxChannel * volume = getInputChannel(kInput_Volume, nullptr);
	const int maxInstances = getInputInt(kInput_MaxInstances, kMaxInstances);
	const OutputMode _outputMode = (OutputMode)getInputInt(kInput_OutputMode, 0);
	const bool muted = getInputBool(kInput_Muted, false);
	
	auto * audioGraphMgr = g_currentVfxGraph->context->tryGetSystem<AudioGraphManager>();
	
	if (isPassthrough || filename == nullptr || volume == nullptr || context == nullptr)
	{
		currentFilename.clear();
		
		for (int i = 0; i < kMaxInstances; ++i)
		{
			if (instances[i] != nullptr)
				audioGraphMgr->free(instances[i], true);
		}
		
		voicesData.free();
		voicesOutput.reset();
		
		updateDynamicInputs();
		
		return;
	}
	
	if (filename != currentFilename)
	{
		currentFilename = filename;
		
		for (int i = 0; i < kMaxInstances; ++i)
		{
			if (instances[i] != nullptr)
				audioGraphMgr->free(instances[i], true);
		}
	}
	
	// update voice muting (before adding instances)
	
	voiceMgr.setMuted(muted);
	
	// add or remove instances based on the volume input
	
	VfxChannelZipper volumeZipper({ volume });
	
	int index = 0;
	int numInstances = 0;
	
	AudioGraphInstance * newInstances[kMaxInstances];
	int numNewInstances = 0;
	
	while (!volumeZipper.done() && index < kMaxInstances && numInstances < maxInstances)
	{
		const float volume = volumeZipper.read(0, 1.f);
		
		if (volume == 0.f)
		{
			if (instances[index] != nullptr)
			{
				auto t1 = g_TimerRT.TimeUS_get();
				audioGraphMgr->free(instances[index], true);
				auto t2 = g_TimerRT.TimeUS_get();
				
				addHistoryElem(kHistoryType_InstanceFree, (t2 - t1) / 1000.0);
			}
		}
		else
		{
			if (instances[index] == nullptr)
			{
				auto t1 = g_TimerRT.TimeUS_get();
				instances[index] = audioGraphMgr->createInstance(filename, context, true);
				auto t2 = g_TimerRT.TimeUS_get();
				
				addHistoryElem(kHistoryType_InstanceCreate, (t2 - t1) / 1000.0);
				
				newInstances[numNewInstances] = instances[index];
				numNewInstances++;
			}
			
			numInstances++;
		}
		
		//
		
		volumeZipper.next();
		
		index++;
	}
	
	while (index < kMaxInstances)
	{
		if (instances[index] != nullptr)
			audioGraphMgr->free(instances[index], true);
		
		index++;
	}
	
	// update dynamic inputs (before we update the control values, and after adding new instances)
	
	updateDynamicInputs();
	
// todo : add dynamic outputs for events
	
	// update control values (after updating the dynamic inputs)
	
	const VfxChannel * channels[128];
	int numChannels;
	
	listChannels(channels, volume, numChannels, 128);
	
	VfxChannelZipper zipper(channels, numChannels);
	
	numInstances = 0;
	
	int inputIndex = 0;
	
	for (auto & dynamicInput : dynamicInputs)
	{
		volumeZipper.restart();
		zipper.restart();
		
		auto input = tryGetInput(kInput_COUNT + inputIndex);
		
		Assert(input != nullptr);
		if (input != nullptr && input->type == kVfxPlugType_Channel)
		{
			int instanceIndex = 0;
			
			while (!volumeZipper.done() && instanceIndex < kMaxInstances)
			{
				const float volume = volumeZipper.read(0, 1.f);
				
				if (volume == 0.f)
				{
					Assert(instances[instanceIndex] == nullptr);
				}
				else if (instanceIndex < kMaxInstances && numInstances < maxInstances)
				{
					Assert(instances[instanceIndex] != nullptr);
					
					auto audioGraph = instances[instanceIndex]->audioGraph;
					
					audioGraph->lockControlValues();
					{
						for (auto & controlValue : audioGraph->controlValues)
						{
							if (controlValue.name == dynamicInput.name)
							{
								controlValue.desiredX = zipper.read(inputIndex + 1, controlValue.defaultX);
							}
						}
					}
					audioGraph->unlockControlValues();
					
					numInstances++;
				}
				
				volumeZipper.next();
				zipper.next();
				
				instanceIndex++;
			}
		}
		
		inputIndex++;
	}
	
	// send the begin trigger for new instances (after updating the control values)
	
	for (int i = 0; i < numNewInstances; ++i)
	{
		if (newInstances[i] != nullptr)
		{
			Assert(newInstances[i]->audioGraph->isPaused);
			newInstances[i]->audioGraph->isPaused = false;
			
			// todo : there should be an on-start type of trigger
			newInstances[i]->audioGraph->triggerEvent("begin");
		}
	}
	
	// generate channel data from audio signals
	
	audioGraphMgr->lockAudio(); // prevent the audio thread from generating new voice samples while we're generating audio here
	{
		// we want to extract the actual audio signals, so make sure we're not muted
		// note : setMuted will swap the audio sources on the voices, so it must be done safely within the scope of the audio mutex!
		voiceMgr.setMuted(false);
		
		const int numSamples = AUDIO_UPDATE_SIZE;
		const int numVoices = voiceMgr.voiceInfos.size();
		const int numChannels =
			_outputMode == kOutputMode_Mono ? 1 :
			_outputMode == kOutputMode_Stereo ? 2 :
			numVoices;

		const AudioVoiceManager::OutputMode outputMode =
			_outputMode == kOutputMode_Mono ? AudioVoiceManager::kOutputMode_Mono :
			_outputMode == kOutputMode_Stereo ? AudioVoiceManager::kOutputMode_Stereo :
			AudioVoiceManager::kOutputMode_MultiChannel;
		
		voicesData.allocOnSizeChange(numChannels * AUDIO_UPDATE_SIZE);
		voicesOutput.setData2D(voicesData.data, true, AUDIO_UPDATE_SIZE, numChannels);
		
		AudioVoice ** voices = (AudioVoice**)alloca(numVoices * sizeof(AudioVoice*));
		int voiceIndex = 0;
		for (auto & voiceInfo : voiceMgr.voiceInfos)
			voices[voiceIndex++] = voiceInfo.voice;
		
		Assert(voiceIndex == numVoices);
			
	// fixme : limiting isn't really possible, as both the main and audio thread would update the measured peak state. unless we maintain and perform limiting ourselves
		const bool limit = false;
		const float limitPeak = 1.f;
		
		AudioVoiceManager::generateAudio(
			voices, numVoices,
			voicesData.data, numSamples, numChannels,
			limit, limitPeak,
			false,
			1.f,
			outputMode, false);
		
		// restore voice muting
		voiceMgr.setMuted(muted);
	}
	audioGraphMgr->unlockAudio();
}

void VfxNodeAudioGraphPoly::getDescription(VfxNodeDescription & d)
{
	int numInstances = 0;
	
	for (int i = 0; i < kMaxInstances; ++i)
		if (instances[i] != nullptr)
			numInstances++;
	
	d.add("instances: %d / %d (max)", numInstances, kMaxInstances);
	d.newline();
	
	d.add("history:");
	if (historySize == 0)
		d.add("n/a");
	else
	{
		int index = historySize < kMaxHistory ? 0 : historyWritePos;
		
		for (int i = 0; i < historySize; ++i)
		{
			auto & e = history[index];
			
			if (e.type == kHistoryType_InstanceCreate)
				d.add("[create] time: %.2fms", e.value);
			if (e.type == kHistoryType_InstanceFree)
				d.add("[free] time: %.2fms", e.value);
			
			index = (index + 1) % kMaxHistory;
		}
	}
}
