#define PI 3.1415926535897932384626433832795

// --- Normal Distribution function ---

float D_GGX(float NdotH, float roughness)
{
    float alpha = roughness * roughness;
    float alpha2 = alpha * alpha;
    float denom = NdotH * NdotH * (alpha2 - 1.0) + 1.0;
    return alpha2 / (PI * denom*denom);
}

// --- Geometric Shadowing function ---

float G_SchlicksmithGGX(float NdotL, float NdotV, float roughness)
{
    float r = (roughness + 1.0);
    float k = (r*r) / 8.0;
    float GL = NdotL / (NdotL * (1.0 - k) + k);
    float GV = NdotV / (NdotV * (1.0 - k) + k);
    return GL * GV;
}

// --- Fresnel function ---

vec3 F_Schlick(float cosTheta, vec3 F0)
{
    // note : F0 and F90 are the reflectance at 0 and 90 degrees (grazing angle)
    vec3 F90 = clamp(F0 * (1.0 / 0.04), vec3(0.0), vec3(1.0)); // 1.0 for F0 >= 0.04. fade out to zero if below. this to give material a chance to completely disable fresnel at 0.0. note : 0.04 is not arbitrality chosen. it's the minimum 'metallic' value for regular dialectrics
    return F0 + (F90 - F0) * pow(1.0 - cosTheta, 5.0);
}

vec3 F_SchlickR(float cosTheta, vec3 F0, float roughness)
{
    // note : F0 and F90 are the reflectance at 0 and 90 degrees (grazing angle)
    vec3 F90 = clamp(F0 * (1.0 / 0.04), vec3(0.0), vec3(1.0)); // 1.0 for F0 >= 0.04. fade out to zero if below. this to give material a chance to completely disable fresnel at 0.0. note : 0.04 is not arbitrality chosen. it's the minimum 'metallic' value for regular dialectrics
    return F0 + (max(vec3(F90 - roughness), F0) - F0) * pow(1.0 - cosTheta, 5.0);
}

// --- specular model ---

// todo : inside the shaders: apply fade out due to ddx/ddy being high, to avoid extreme aliasing/shimmer when non-rough materials ar far away

vec3 specularContribution(
    float NdotH,
    float NdotV,
    float NdotL,
    vec3 F0,
    vec3 metallic,
    float roughness,
    vec3 baseColor)
{
    if (NdotL <= 0.0)
        return vec3(0.0);
    else
    {
        // D = Normal distribution (Distribution of the microfacets)
        float D = D_GGX(NdotH, roughness);

        // G = Geometric shadowing term (Microfacets shadowing)
        float G = G_SchlicksmithGGX(NdotL, NdotV, roughness);
        
        // F = Fresnel factor (Reflectance depending on angle of incidence)
        vec3 F = F_Schlick(NdotV, F0);
        
        // Cook-Torrance (Brdf model)
        vec3 specular = D * F * G / (4.0 * NdotL * NdotV + 0.001);
        
        return specular;
    }
}

// --- lighting computation ---

struct Lighting_SurfaceProperties
{
    // surface vectors

    vec3 position;
    
    vec3 N;
    vec3 V;
    vec3 R;

    // material properties

    vec3 baseColor;
    float opacity;
    vec3 metallic;
    float roughness;
};

struct Lighting_LightingResult
{
    vec3 diffuse;
    vec3 specular;
    float lightIncidence; // Give pbr shaders control over whether or not to integrate the light incidence factor. For correct results, you'd want to. But, flat shading or not is an artistic choice we want to support.
};

Lighting_LightingResult computeLighting(
    Lighting_SurfaceProperties surfaceProperties,
    vec3 lightDir)
{
    vec3 L = -lightDir;
    vec3 V = surfaceProperties.V;
    vec3 N = surfaceProperties.N;

    vec3 H = normalize(V + L);

    // -- precalculate vectors and dot products
    
    float NdotH = max(dot(N, H), 0.0);
    float NdotV = max(dot(N, V), 0.004); // the geometric self-shadowing model has a nasty floating point cancellation which would give precision issues near the 'zero point singularity'. without this clamp, at grazing angles, the resulting colors turn to black. the value of 0.004 has been determined through visual inspection of the result, near grazing angles
    float NdotL = max(dot(N, L), 0.004);

    // -- specular

    vec3 F0 = surfaceProperties.metallic;

    vec3 specular = specularContribution(
        NdotH,
        NdotV,
        NdotL,
        F0,
        surfaceProperties.metallic,
        surfaceProperties.roughness,
        surfaceProperties.baseColor);

    // -- diffuse

    vec3 F = F_SchlickR(
        NdotV,
        F0,
        surfaceProperties.roughness);

    // for energy conservation: reduce diffuse by energy lost due to reflections
    vec3 kD = (vec3(1.0) - F);

    vec3 diffuse = kD * surfaceProperties.baseColor / PI;

    // -- debugging

#if 0
    specular *= PI;
    diffuse *= PI;
#endif

    // -- result

    Lighting_LightingResult result;
    result.specular = specular;
    result.diffuse = diffuse;
    result.lightIncidence = NdotL;

    return result;
}

#undef PI
