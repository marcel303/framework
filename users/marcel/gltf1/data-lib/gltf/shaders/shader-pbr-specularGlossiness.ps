include engine/ShaderPS.txt
include engine/ShaderUtil.txt

include gltf/shaders/lighting.txt
include gltf/shaders/utils.txt

// shader based on: https://github.com/SaschaWillems/Vulkan-glTF-PBR/blob/master/data/shaders/pbr.frag

// material maps

uniform vec4 u_diffuseFactor;
uniform sampler2D diffuseTexture;
uniform float diffuseTextureCoord;

uniform vec3 u_specularFactor;
uniform float u_glossinessFactor;
uniform sampler2D specularGlossinessTexture;
uniform float specularGlossinessTextureCoord;

// extra maps

uniform sampler2D normalTexture;
uniform float normalTextureCoord;

uniform sampler2D occlusionTexture;
uniform float occlusionTextureCoord;
uniform float u_occlusionStrength;

uniform vec3 u_emissiveFactor;
uniform sampler2D emissiveTexture;
uniform float emissiveTextureCoord;

// material common

uniform float u_alphaMask;
uniform float u_alphaMaskCutoff;

// scene common

uniform vec3 scene_camPos;
uniform vec3 scene_lightPos;
uniform vec3 scene_lightDir;

// from vertex shader

shader_in vec3 v_position_view;
shader_in vec4 v_color;
shader_in vec2 v_texcoord0;
shader_in vec2 v_texcoord1;
shader_in vec3 v_normal_view;

// ---

#define kMinRoughness 0.04

vec4 gltfTexture(sampler2D s, float texcoord)
{
    if (texcoord < 1.0)
        return texture(s, v_texcoord0);
    else
        return texture(s, v_texcoord1);
}

vec3 perturbNormal()
{
    vec3 normal_view = normalize(v_normal_view);

    if (normalTextureCoord < 0.0)
        return normal_view;

    vec3 tangentNormal = gltfTexture(normalTexture, normalTextureCoord).xyz * 2.0 - 1.0;

    return perturbNormal(v_position_view, normal_view, v_texcoord0, tangentNormal);
}

void main()
{
    // -- unpack diffuse color and alpha

    vec4 baseColor = u_diffuseFactor;

    if (diffuseTextureCoord >= 0.0)
    {
        vec4 baseColorFromTexture = gltfTexture(diffuseTexture, diffuseTextureCoord);

        /*
        The baseColorTexture uses the sRGB transfer function and must be converted to
        linear space before it is used for any computations.
        */

        baseColorFromTexture.rgb = srgbToLinear(baseColorFromTexture.rgb);

        baseColor *= baseColorFromTexture;
    }
    else
    {
    // todo : need a way to set default values for vertex inputs
    //        otherwise meshes without vertex colors get random data

        /*
        if a primitive specifies a vertex color using the attribute semantic
        property COLOR_0, then this value acts as an additional linear multiplier
        to baseColor.
        */

        //baseColor *= v_color;
    }

    // -- perform alpha test

    if (u_alphaMask != 0.0)
    {
        if (baseColor.a < u_alphaMaskCutoff)
            discard;
    }

    // -- calculate light vectors

    vec3 N = perturbNormal();
    vec3 V = normalize(-v_position_view); // note : this equals 'scene_camPos - v_position_view', since the camera position in view-space is always at (0, 0, 0) we can simplify
    vec3 R = -normalize(reflect(V, N));

    // -- unpack specular and roughness

    vec3 specular = u_specularFactor;
    float glossiness = u_glossinessFactor;
    
    if (specularGlossinessTextureCoord >= 0.0)
    {
        vec4 specularGlossiness = gltfTexture(specularGlossinessTexture, specularGlossinessTextureCoord);

        /*
        Both textures are encoded with the sRGB transfer function and must be converted to linear space before they are used for any computations.
        source: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_pbrSpecularGlossiness
        */
        specularGlossiness.rgb = srgbToLinear(specularGlossiness.rgb);

        specular *= specularGlossiness.rgb;
        glossiness *= specularGlossiness.a;
    }

    float roughness = clamp(1.0 - glossiness, kMinRoughness, 1.0);

    // -- specular

    //vec3 F0 = specular;
    vec3 F0 = mix(vec3(0.04), baseColor.rgb, specular);

    vec3 L = normalize(scene_lightDir.xyz);
    vec3 Lo = specularContribution(L, V, N, F0, specular, roughness, baseColor.rgb);

    // -- diffuse

    vec3 F = F_SchlickR(max(dot(N, V), 0.0), F0, roughness);

    vec3 kD = vec3(1.0) - F;

    float specularStrength = max(specular.r, max(specular.g, specular.b));
    kD *= 1.0 - specularStrength;
    //kD *= vec3(1.0) - specular;
    
    vec3 diffuse = kD * baseColor.rgb;

    // -- ambient occlusion

    if (occlusionTextureCoord >= 0.0)
    {
        float ao = gltfTexture(occlusionTexture, occlusionTextureCoord).r;

        ao = mix(1.0, ao, u_occlusionStrength);

        diffuse *= ao;
    }

    // -- add all terms

    vec3 color = diffuse + Lo;

    // -- convert linear to gamma space

    color = linearToSrgb(color);

    // -- add emissive

    vec3 emissive = u_emissiveFactor;

    if (emissiveTextureCoord >= 0.0)
    {
        emissive *= gltfTexture(emissiveTexture, emissiveTextureCoord).rgb;
    }

    color += emissive;

    // -- store

//    color.rgb = srgbToLinear(baseColor.rgb);
//    color.rgb = vec3(0.0);
//    color.rgb = R;
//    color.rgb = vec3(glossiness);
//    color.rgb = N;
//    color.rgb = specular;

    shader_fragColor = vec4(color, baseColor.a);

#if 0 // todo : use temporal or dither based alpha offset to improve the blending result we get when using the alpha to coverage method
    // Iestyn's RGB dither (7 asm instructions) from Portal 2 X360, slightly modified for VR
    vec2 sampleCoord = v_texcoord0 * 1231541.0;
    vec3 vDither = vec3( dot( vec2( 171.0, 231.0 ), sampleCoord ) );
    vDither = fract( vDither / vec3( 103.0, 71.0, 97.0 ) );
    shader_fragColor.a += (vDither.r - 0.5) / 8.0;
#endif
}
