include engine/ShaderPS.txt
include engine/ShaderUtil.txt

include gltf/shaders/lighting.txt
include gltf/shaders/utils.txt

// shader based on: https://github.com/SaschaWillems/Vulkan-glTF-PBR/blob/master/data/shaders/pbr.frag

// material maps

uniform vec4 u_baseColorFactor;
uniform sampler2D baseColorTexture;
uniform float baseColorTextureCoord;

uniform float u_metallicFactor;
uniform float u_roughnessFactor;
uniform sampler2D metallicRoughnessTexture;
uniform float metallicRoughnessTextureCoord;

// additional maps

uniform sampler2D normalTexture;
uniform float normalTextureCoord;

uniform sampler2D occlusionTexture;
uniform float occlusionTextureCoord;
uniform float u_occlusionStrength;

uniform vec3 u_emissiveFactor;
uniform sampler2D emissiveTexture;
uniform float emissiveTextureCoord;

// material common

uniform float u_alphaMask;
uniform float u_alphaMaskCutoff;

// scene common

uniform vec4 scene_lightParams;
uniform vec3 scene_ambientLightColor;

// from vertex shader
shader_in vec3 v_position_view;
shader_in vec4 v_color;
shader_in vec2 v_texcoord0;
shader_in vec2 v_texcoord1;
shader_in vec3 v_normal_view;

#define kMinRoughness 0.04

vec4 gltfTexture(sampler2D s, float texcoord)
{
    if (texcoord < 1.0)
        return texture(s, v_texcoord0);
    else
        return texture(s, v_texcoord1);
}

vec3 perturbNormal()
{
    vec3 normal_view = normalize(v_normal_view);

    if (normalTextureCoord < 0.0)
        return normal_view;

    vec3 tangentNormal = gltfTexture(normalTexture, normalTextureCoord).xyz * 2.0 - 1.0;

    return perturbNormal(v_position_view, normal_view, v_texcoord0, tangentNormal);
}

struct Lighting_SurfaceProperties
{
    // surface vectors

    vec3 position;
    
    vec3 N;
    vec3 V;
    vec3 R;

    // material properties

    vec3 baseColor;
    vec3 metallic;
    float roughness;
};

#define kLightType_Directional 0
#define kLightType_Point 1

struct Lighting_LightProperties
{
    float type;
    vec3 positionOrDirection;
};

struct Lighting_LightingResult
{
    vec3 diffuse;
    vec3 specular;
};

Lighting_LightingResult computeLighting(Lighting_SurfaceProperties surfaceProperties, Lighting_LightProperties lightProperties)
{
    vec3 lightDir;
    float lightAttenuation;

    if (lightProperties.type == 0.0)
    {
        lightDir = lightProperties.positionOrDirection;
        lightAttenuation = 1.0;
    }
    else
    {
        vec3 lightPos = lightProperties.positionOrDirection;

        vec3 lightToSurface = surfaceProperties.position - lightPos;
        lightDir = normalize(lightToSurface);
        lightAttenuation = 1.0 / dot(lightToSurface, lightToSurface);
    }

    // -- specular

    vec3 F0 = mix(vec3(0.04), surfaceProperties.baseColor, surfaceProperties.metallic);

    vec3 L = -lightDir;

    vec3 Lo = specularContribution(
        L,
        surfaceProperties.V,
        surfaceProperties.N,
        F0,
        surfaceProperties.metallic,
        surfaceProperties.roughness,
        surfaceProperties.baseColor);

    // -- diffuse

    vec3 F = F_SchlickR(max(0.0, dot(surfaceProperties.N, surfaceProperties.V)), F0, surfaceProperties.roughness);

    vec3 kD = vec3(1.0) - F;
    
    kD *= vec3(1.0) - surfaceProperties.metallic;
    
    vec3 diffuse = kD * surfaceProperties.baseColor;

    diffuse *= max(0.0, dot(surfaceProperties.N, L));

    // -- attenuation

    Lo *= lightAttenuation;
    diffuse *= lightAttenuation;

    // -- result

    Lighting_LightingResult result;
    result.specular = Lo;
    result.diffuse = diffuse;

    return result;
}

void main()
{
    // -- unpack base color and alpha

    vec4 baseColor = u_baseColorFactor;

    if (baseColorTextureCoord >= 0.0)
    {
        vec4 baseColorFromTexture = gltfTexture(baseColorTexture, baseColorTextureCoord);

        /*
        The baseColorTexture uses the sRGB transfer function and must be converted to
        linear space before it is used for any computations.
        */

        baseColorFromTexture.rgb = srgbToLinear(baseColorFromTexture.rgb);

        baseColor *= baseColorFromTexture;
    }
    else
    {
    // todo : need a way to set default values for vertex inputs
    //        otherwise meshes without vertex colors get random data

        /*
        if a primitive specifies a vertex color using the attribute semantic
        property COLOR_0, then this value acts as an additional linear multiplier
        to baseColor.
        */

        //baseColor *= v_color;
    }

    // -- perform alpha test

    if (u_alphaMask != 0.0)
    {
        if (baseColor.a < u_alphaMaskCutoff)
            discard;
    }

    // -- calculate surface vectors

    vec3 N = perturbNormal();
    vec3 V = normalize(-v_position_view); // note : this equals 'cameraPosition_view - v_position_view', since the camera position in view-space is always at (0, 0, 0) we can simplify
    vec3 R = -normalize(reflect(V, N));

    // -- unpack metallic and roughness

    float metallic = u_metallicFactor;
    float roughness = u_roughnessFactor;
    
    if (metallicRoughnessTextureCoord >= 0.0)
    {
        vec4 metallicRoughness = gltfTexture(metallicRoughnessTexture, metallicRoughnessTextureCoord);

        metallic *= metallicRoughness.b;
        roughness *= metallicRoughness.g;
    }

    roughness = clamp(roughness, kMinRoughness, 1.0);

    // -- compute lighting

    Lighting_SurfaceProperties surfaceProperties;
    surfaceProperties.position = v_position_view;
    surfaceProperties.N = N;
    surfaceProperties.V = V;
    surfaceProperties.R = R;
    surfaceProperties.baseColor = baseColor.rgb;
    surfaceProperties.metallic = vec3(metallic);
    surfaceProperties.roughness = roughness;

    vec3 Lo = vec3(0.0);
    vec3 diffuse = vec3(0.0);

    {
        Lighting_LightProperties lightProperties;
        lightProperties.type = scene_lightParams.w;
        lightProperties.positionOrDirection = scene_lightParams.xyz;

        Lighting_LightingResult lightingResult = computeLighting(surfaceProperties, lightProperties);

        Lo += lightingResult.specular;
        diffuse += lightingResult.diffuse;
    }

    // -- ambient occlusion
    
    if (occlusionTextureCoord >= 0.0)
    {
        float ao = gltfTexture(occlusionTexture, occlusionTextureCoord).r;

        ao = mix(1.0, ao, u_occlusionStrength);

        diffuse *= ao;
    }

    // -- add all terms

    vec3 color = diffuse + Lo;

    // -- add ambient light

    color += baseColor.rgb * scene_ambientLightColor;

    // -- convert linear to gamma space

    color = linearToSrgb(color);

    // -- add emissive

    vec3 emissive = u_emissiveFactor;

    if (emissiveTextureCoord >= 0.0)
    {
        emissive *= gltfTexture(emissiveTexture, emissiveTextureCoord).rgb;
    }

    //color += emissive;

    // -- store

//    color.rgb = R;
//    color.rgb = vec3(metallic);
//    color.rgb = vec3(roughness);
    //color.rgb = N;
//    color.rgb = u_baseColorFactor.rgb;
    //color.rgb = vec3(u_metallicFactor);
    //color.rgb = vec3(u_roughnessFactor);

    shader_fragColor = vec4(color, baseColor.a);
}
