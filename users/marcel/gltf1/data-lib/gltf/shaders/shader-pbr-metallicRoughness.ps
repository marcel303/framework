include engine/ShaderPS.txt
include engine/ShaderUtil.txt

include gltf/shaders/lighting.txt
include gltf/shaders/utils.txt

// shader based on: https://github.com/SaschaWillems/Vulkan-glTF-PBR/blob/master/data/shaders/pbr.frag

// material maps

uniform vec4 u_baseColorFactor;
uniform sampler2D baseColorTexture;
uniform float baseColorTextureCoord;

uniform float u_metallicFactor;
uniform float u_roughnessFactor;
uniform sampler2D metallicRoughnessTexture;
uniform float metallicRoughnessTextureCoord;

// additional maps

uniform sampler2D normalTexture;
uniform float normalTextureCoord;

uniform sampler2D occlusionTexture;
uniform float occlusionTextureCoord;
uniform float u_occlusionStrength;

uniform vec3 u_emissiveFactor;
uniform sampler2D emissiveTexture;
uniform float emissiveTextureCoord;

// material common

uniform float u_alphaMask;
uniform float u_alphaMaskCutoff;

// scene common

uniform vec3 scene_camPos;
uniform vec3 scene_lightDir;
#define scene_gamma 2.2

// from vertex shader
shader_in vec3 v_position_view;
shader_in vec4 v_color;
shader_in vec2 v_texcoord0;
shader_in vec2 v_texcoord1;
shader_in vec3 v_normal_view;

#define kMinRoughness 0.04

vec4 gltfTexture(sampler2D s, float texcoord)
{
    if (texcoord < 1.0)
        return texture(s, v_texcoord0);
    else
        return texture(s, v_texcoord1);
}

vec3 perturbNormal()
{
    vec3 normal_view = normalize(v_normal_view);

    if (normalTextureCoord < 0.0)
        return normal_view;

    vec3 tangentNormal = gltfTexture(normalTexture, normalTextureCoord).xyz * 2.0 - 1.0;

    return perturbNormal(v_position_view, normal_view, v_texcoord0, tangentNormal);
}

void main()
{
    // -- unpack base color and alpha

    vec4 baseColor = u_baseColorFactor;

    if (baseColorTextureCoord >= 0.0)
    {
        vec4 baseColorFromTexture = gltfTexture(baseColorTexture, baseColorTextureCoord);

        /*
        The baseColorTexture uses the sRGB transfer function and must be converted to
        linear space before it is used for any computations.
        */

        baseColorFromTexture.rgb = srgbToLinear(baseColorFromTexture.rgb);

        baseColor *= baseColorFromTexture;
    }
    else
    {
    // todo : need a way to set default values for vertex inputs
    //        otherwise meshes without vertex colors get random data

        /*
        if a primitive specifies a vertex color using the attribute semantic
        property COLOR_0, then this value acts as an additional linear multiplier
        to baseColor.
        */

        //baseColor *= v_color;
    }

    // -- perform alpha test

    if (u_alphaMask != 0.0)
    {
        if (baseColor.a < u_alphaMaskCutoff)
            discard;
    }

    // -- calculate light vectors

    vec3 N = perturbNormal();
    vec3 V = normalize(scene_camPos - v_position_view);
    vec3 R = -normalize(reflect(V, N));

    // -- unpack metallic and roughness

    float metallic = u_metallicFactor;
    float roughness = u_roughnessFactor;
    
    if (metallicRoughnessTextureCoord >= 0.0)
    {
        vec4 metallicRoughness = gltfTexture(metallicRoughnessTexture, metallicRoughnessTextureCoord);

        metallic *= metallicRoughness.b;
        roughness *= metallicRoughness.g;
    }

    roughness = clamp(roughness, kMinRoughness, 1.0);

    // -- specular

    float specular = metallic;

    vec3 F0 = mix(vec3(0.04), baseColor.rgb, metallic);

    vec3 L = normalize(scene_lightDir.xyz);
    vec3 Lo = specularContribution(L, V, N, F0, vec3(metallic), roughness, baseColor.rgb);

    // -- diffuse

    vec3 F = F_SchlickR(max(dot(N, V), 0.0), F0, roughness);

    vec3 kD = vec3(1.0) - F;
    
    kD *= 1.0 - metallic;
    
    vec3 diffuse = kD * baseColor.rgb;

    // -- ambient occlusion
    
    if (occlusionTextureCoord >= 0.0)
    {
        float ao = gltfTexture(occlusionTexture, occlusionTextureCoord).r;

        ao = mix(1.0, ao, u_occlusionStrength);

        diffuse *= ao;
    }

    // -- add all terms

    vec3 color = diffuse + Lo;

    // -- convert linear to gamma space

    color = linearToSrgb(color);

    // -- add emissive

    vec3 emissive = u_emissiveFactor;

    if (emissiveTextureCoord >= 0.0)
    {
        emissive *= gltfTexture(emissiveTexture, emissiveTextureCoord).rgb;
    }

    //color += emissive;

    // -- store

//    color.rgb = R;
//    color.rgb = vec3(metallic);
//    color.rgb = vec3(roughness);
    //color.rgb = N;
//    color.rgb = u_baseColorFactor.rgb;
    //color.rgb = vec3(u_metallicFactor);
    //color.rgb = vec3(u_roughnessFactor);

    shader_fragColor = vec4(color, baseColor.a);
}
