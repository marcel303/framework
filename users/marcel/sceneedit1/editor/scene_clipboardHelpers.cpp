#include "component.h"
#include "componentType.h"
#include "helpers.h" // findComponentType
#include "helpers2.h" // g_typeDB
#include "lineReader.h"
#include "lineWriter.h"
#include "Log.h"
#include "reflection-textio.h"
#include "scene.h"
#include "scene_clipboardHelpers.h"
#include "TextIO.h"

bool copySceneNodeToText(const TypeDB & typeDB, const SceneNode & node, LineWriter & line_writer, int indent)
{
	for (ComponentBase * component = node.components.head; component != nullptr; component = component->next_in_set)
	{
		auto * component_type = findComponentType(component->typeIndex());
		
		Assert(component_type != nullptr);
		if (component_type == nullptr)
			return false;
		
		line_writer.append_indented_line(indent, component_type->typeName);
		
		indent++;
		{
			if (object_tolines_recursive(g_typeDB, component_type, component, line_writer, indent) == false)
				continue;
		}
		indent--;
	}
	
	return true;
}

bool pasteSceneNodeFromText(const TypeDB & typeDB, LineReader & line_reader, SceneNode & node)
{
	for (;;)
	{
		const char * component_type_name = line_reader.get_next_line(true);
		
		if (component_type_name == nullptr)
			break;
		
		if (component_type_name[0] == '\t')
		{
			// only one level of indentation may be added per line
			
			LOG_ERR("more than one level of indentation added on line %d", line_reader.get_current_line_index());
			return false;
		}
		
		auto * component_type = findComponentType(component_type_name);
		
		Assert(component_type != nullptr);
		if (component_type == nullptr)
		{
			node.freeComponents();
			return false;
		}
		
		auto * component = component_type->componentMgr->createComponent(node.components.id);
		
		line_reader.push_indent();
		{
			if (object_fromlines_recursive(g_typeDB, component_type, component, line_reader) == false)
			{
				node.freeComponents();
				return false;
			}
		}
		line_reader.pop_indent();
		
		node.components.add(component);
	}
	
	return true;
}

//

#include "sceneIo.h"
#include "StringEx.h"

static void flattenSceneNodeTree(const Scene & scene, const int rootNodeId, std::vector<int> & result)
{
	result.push_back(rootNodeId);
	
	auto & node = scene.getNode(rootNodeId);
	
	for (auto childNodeId : node.childNodeIds)
		flattenSceneNodeTree(scene, childNodeId, result);
}

bool copySceneNodeTreeToText(const TypeDB & typeDB, const Scene & scene, const int rootNodeId, LineWriter & line_writer, int indent)
{
	bool result = true;
	
	//line_writer.append_indented_line(indent, "entities");
	
	//indent++;
	{
		// gather nodes
		
		std::vector<int> nodeIds;
		flattenSceneNodeTree(scene, rootNodeId, nodeIds);
		
		// write entities
		
		scene.assignAutoGeneratedNodeNames();
		
		for (auto nodeId : nodeIds)
		{
			auto & node = scene.getNode(nodeId);
		
			result &= writeSceneEntityToLines(typeDB, node, line_writer, indent);
			
			line_writer.append('\n');
		}
	}
	//indent--;

	// write scene structure
	
	line_writer.append_indented_line(indent, "scene");
	
	indent++;
	{
		// write node structure
		
		line_writer.append_indented_line(indent, "nodes");
		
		indent++;
		{
			result &= writeSceneNodeTreeToLines(scene, rootNodeId, line_writer, indent);
		}
		indent--;
	}
	indent--;
	
	return result;
}

bool pasteSceneNodeTreeFromText(const TypeDB & typeDB, LineReader & line_reader, Scene & scene)
{
	bool result = true;
	
	result &= parseSceneFromLines(typeDB, line_reader, "", scene);
	
	return result;
}
