include engine/ShaderPS.txt

uniform mat4x4 projectionToView;

uniform vec3 lightPosition_view;
uniform vec3 lightColor;
uniform vec2 lightAttenuationParams;
float attenuationBegin = lightAttenuationParams.x;
float attenuationEnd = lightAttenuationParams.y;

uniform sampler2D depthTexture;
uniform sampler2D normalTexture;

shader_in vec2 texcoord;

// todo : make include file for depth to view

vec3 depthToViewPosition(float depth, vec2 texcoord, mat4x4 projectionToView)
{
#if defined(GL_core_profile) || true
	vec3 coord = vec3(texcoord, depth) * 2.0 - vec3(1.0);
#else
	vec3 coord = vec3(vec2(texcoord.x, 1.0 - texcoord.y) * 2.0 - vec2(1.0), depth);
#endif

	vec4 position_projection = vec4(coord, 1.0);
	vec4 position_view = projectionToView * position_projection;

	position_view /= position_view.w;

	return position_view.xyz;
}

void main()
{
	float camera_view_depth = texture(depthTexture, texcoord).x;

	if (camera_view_depth == 1.0)
	{
		// scene background
		shader_fragColor = vec4(0.0);
		return;
	}

	vec3 position_view = depthToViewPosition(camera_view_depth, texcoord, projectionToView);

	vec3 positionToLight = lightPosition_view - position_view;
	float distanceToLight = length(positionToLight);
	vec3 lightDir_view = positionToLight / (distanceToLight + 0.000001);

	vec3 normal_view = texture(normalTexture, texcoord).xyz;

	float value = max(0.0, dot(lightDir_view, normal_view));

	float attenuation = clamp(1.0 - (distanceToLight - attenuationBegin) / (attenuationEnd - attenuationBegin), 0.0, 1.0);

	vec3 lightColor = lightColor * value * attenuation;

	shader_fragColor = vec4(lightColor, 1.0);
}
