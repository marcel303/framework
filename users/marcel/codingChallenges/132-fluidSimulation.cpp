#include "framework.h"
#include "Timer.h"
#include <vector>

/*
https://mikeash.com/pyblog/fluid-simulation-for-dummies.html
Coding Challenge #132: Fluid Simulation
https://www.youtube.com/watch?v=alhpH6ECFvQ
*/

/*

idea : experiment with the following boundary modes, and external forces,
from: http://karlsims.com/fluid-flow.html,

Zero: using a value of zero beyond the grid will avoid flow toward or away from the boundary, as if the fluid is contained in a box, because any edge cell's component of flow normal to the boundary would typically create a non-zero divergence and be removed. The divergence-removal examples above used this mode.
Repeat: repeating the flow value from the nearest edge cell will instead allow flow toward or away from the edges as if the fluid can exit or enter the grid.
Scaled repeat: combining zero and repeat edge-modes can also be useful. Using a scaled value of the nearest edge cell can give a soft boundary effect that slows down the flow at the edges but doesn't completely stop it. Alternatively, using zero for the flow component normal to the boundary, and repeat mode for the component parallel to the boundary, can give a more slippery edge effect.
Wrap: copying the flow value from the opposite side of the grid can create a wrap-around behavior where flow exiting on one side of the grid enters on the other.

Obstacles can also be added to the grid with similar boundary conditions by forcing the flow, or its normal component, to zero at their locations.

--

Realistic looking fluid behavior can be generated by alternating between the fluid momentum and divergence-removal steps described above. However some non-zero flow velocity needs to be set somehow, either procedurally or interactively. For example, adding linear flow at specific locations can create a squirting ink effect (see below), or tracking mouse or camera motion can be used to interactively push the fluid.

Other forces can be added to simulate various physical phenomena:

Gravity or buoyency can affect some parts of the fluid differently than others using a tracer image that represents the fluid density.
Damping or friction can reduce the flow velocity over time.
Viscosity can be simulated by diffusing the flow field slightly at each time step so the velocities become more like their neighbors. Note that the repeated resampling of the flow field will also cause a small amount of diffusion.
Cohesive forces can be approximated by using a tracer image to track different fluid substances, such as oil vs water, and then pushing the substances toward areas of the same type, moving convex boundaries inwards and concave boundaries outwards.

*/

#define SCALE 2

#define THREE_DIMENSIONAL 0

#define IX_2D(x, y) ((x) + (y) * N)
#define IX_3D(x, y, z) ((x) + (y) * N + (z) * N * N)

static void set_bnd2d(const int b, float * x, const int N)
{
	for (int i = 1; i < N - 1; ++i)
	{
		x[IX_2D(i, 0  )] = b == 2 ? -x[IX_2D(i, 1  )] : x[IX_2D(i, 1  )];
		x[IX_2D(i, N-1)] = b == 2 ? -x[IX_2D(i, N-2)] : x[IX_2D(i, N-2)];
	}
	
	for (int j = 1; j < N - 1; ++j)
	{
		x[IX_2D(0  , j)] = b == 1 ? -x[IX_2D(1  , j)] : x[IX_2D(1  , j)];
		x[IX_2D(N-1, j)] = b == 1 ? -x[IX_2D(N-2, j)] : x[IX_2D(N-2, j)];
	}

    x[IX_2D(0,     0)]   = 0.5f * (x[IX_2D(1,     0)] + x[IX_2D(0,     1)]);
    x[IX_2D(0,   N-1)]   = 0.5f * (x[IX_2D(1,   N-1)] + x[IX_2D(0,   N-2)]);
    x[IX_2D(N-1,   0)]   = 0.5f * (x[IX_2D(N-2,   0)] + x[IX_2D(N-1,   1)]);
    x[IX_2D(N-1, N-1)]   = 0.5f * (x[IX_2D(N-2, N-1)] + x[IX_2D(N-1, N-2)]);
}

static void set_bnd3d(const int b, float * x, const int N)
{
    for(int j = 1; j < N - 1; j++) {
        for(int i = 1; i < N - 1; i++) {
            x[IX_3D(i, j, 0  )] = b == 3 ? -x[IX_3D(i, j, 1  )] : x[IX_3D(i, j, 1  )];
            x[IX_3D(i, j, N-1)] = b == 3 ? -x[IX_3D(i, j, N-2)] : x[IX_3D(i, j, N-2)];
        }
    }

    for(int k = 1; k < N - 1; k++) {
        for(int i = 1; i < N - 1; i++) {
            x[IX_3D(i, 0  , k)] = b == 2 ? -x[IX_3D(i, 1  , k)] : x[IX_3D(i, 1  , k)];
            x[IX_3D(i, N-1, k)] = b == 2 ? -x[IX_3D(i, N-2, k)] : x[IX_3D(i, N-2, k)];
        }
    }

    for(int k = 1; k < N - 1; k++) {
        for(int j = 1; j < N - 1; j++) {
            x[IX_3D(0  , j, k)] = b == 1 ? -x[IX_3D(1  , j, k)] : x[IX_3D(1  , j, k)];
            x[IX_3D(N-1, j, k)] = b == 1 ? -x[IX_3D(N-2, j, k)] : x[IX_3D(N-2, j, k)];
        }
    }

    x[IX_3D(  0,   0,   0)] = 0.333f * (x[IX_3D(  1,   0,   0)] + x[IX_3D(  0,   1,   0)] + x[IX_3D(  0,   0,   1)]);
    x[IX_3D(  0, N-1,   0)] = 0.333f * (x[IX_3D(  1, N-1,   0)] + x[IX_3D(  0, N-2,   0)] + x[IX_3D(  0, N-1,   1)]);
    x[IX_3D(  0,   0, N-1)] = 0.333f * (x[IX_3D(  1,   0, N-1)] + x[IX_3D(  0,   1, N-1)] + x[IX_3D(  0,   0, N-1)]);
    x[IX_3D(  0, N-1, N-1)] = 0.333f * (x[IX_3D(  1, N-1, N-1)] + x[IX_3D(  0, N-2, N-1)] + x[IX_3D(  0, N-1, N-2)]);
    x[IX_3D(N-1,   0,   0)] = 0.333f * (x[IX_3D(N-2,   0,   0)] + x[IX_3D(N-1,   1,   0)] + x[IX_3D(N-1,   0,   1)]);
    x[IX_3D(N-1, N-1,   0)] = 0.333f * (x[IX_3D(N-2, N-1,   0)] + x[IX_3D(N-1, N-2,   0)] + x[IX_3D(N-1, N-1,   1)]);
    x[IX_3D(N-1,   0, N-1)] = 0.333f * (x[IX_3D(N-2,   0, N-1)] + x[IX_3D(N-1,   1, N-1)] + x[IX_3D(N-1,   0, N-2)]);
    x[IX_3D(N-1, N-1, N-1)] = 0.333f * (x[IX_3D(N-2, N-1, N-1)] + x[IX_3D(N-1, N-2, N-1)] + x[IX_3D(N-1, N-1, N-2)]);
}

static void lin_solve2d(const int b, float * __restrict x, const float * __restrict x0, const float a, const float c, const int iter, const int N)
{
    float cRecip = 1.f / c;

// todo : we're updating x[] inside the loop while also reading from it. this doesn't seem right

    for (int k = 0; k < iter; ++k)
    {
		for (int j = 1; j < N - 1; ++j)
		{
			const int index = IX_2D(0, j);
			
			const float * __restrict x0_line = x0 + index;
			      float * __restrict x_line  = x  + index;
			
			float prev_x = x_line[0];
			
			for (int i = 1; i < N - 1; ++i)
			{
			#if 0
				x_line[i] = (x0_line[i] + a * (x_line[i - 1] + x_line[i + 1] + x_line[i - N] + x_line[i + N])) * cRecip;
			#elif 1
				const float curr_x = x_line[i];
				
				x_line[i] = (x0_line[i] + a * ((prev_x + x_line[i + 1]) + (x_line[i - N] + x_line[i + N]))) * cRecip;
				
				prev_x = curr_x;
			#else
				// note : we keep this verion around since it's easier to port to a shader
				x[IX_2D(i, j)] =
					(
						x0[IX_2D(i, j)]
						+ a *
							(
								+x[IX_2D(i+1, j  )]
								+x[IX_2D(i-1, j  )]
								+x[IX_2D(i  , j+1)]
								+x[IX_2D(i  , j-1)]
							)
					) * cRecip;
			#endif
			}
		}

        set_bnd2d(b, x, N);
    }
}

static void lin_solve2d_xy(
	float * __restrict x, const float * __restrict x0,
	float * __restrict y, const float * __restrict y0,
	const float a, const float c, const int iter, const int N)
{
    float cRecip = 1.f / c;

// todo : we're updating x[] inside the loop while also reading from it. this doesn't seem right

    for (int k = 0; k < iter; ++k)
    {
		for (int j = 1; j < N - 1; ++j)
		{
			const int index = IX_2D(0, j);
			
			const float * __restrict x0_line = x0 + index;
			      float * __restrict x_line  = x  + index;
			
			const float * __restrict y0_line = y0 + index;
			      float * __restrict y_line  = y  + index;
			
			float prev_x = x_line[0];
			float prev_y = y_line[0];
			
			for (int i = 1; i < N - 1; ++i)
			{
			#if 0
				x_line[i] = (x0_line[i] + a * (x_line[i - 1] + x_line[i + 1] + x_line[i - N] + x_line[i + N])) * cRecip;
				y_line[i] = (y0_line[i] + a * (y_line[i - 1] + y_line[i + 1] + y_line[i - N] + y_line[i + N])) * cRecip;
			#else
				const float curr_x = x_line[i];
				const float curr_y = x_line[i];
				
				x_line[i] = (x0_line[i] + a * ((prev_x + x_line[i + 1]) + (x_line[i - N] + x_line[i + N]))) * cRecip;
				y_line[i] = (y0_line[i] + a * ((prev_y + y_line[i + 1]) + (y_line[i - N] + y_line[i + N]))) * cRecip;
				
				prev_x = curr_x;
				prev_y = curr_y;
			#endif
			}
		}

        set_bnd2d(1, x, N);
        set_bnd2d(2, y, N);
    }
}

static void lin_solve3d(const int b, float * __restrict x, const float * __restrict x0, const float a, const float c, const int iter, const int N)
{
    float cRecip = 1.f / c;

    for (int k = 0; k < iter; k++)
    {
        for (int m = 1; m < N - 1; m++)
        {
            for (int j = 1; j < N - 1; j++)
            {
				int index = IX_3D(0, j, m);
				
            	const int step_x = 1;
            	const int step_y = N;
            	const int step_z = N * N;
				
				const float * __restrict x0_line = x0 + index;
					  float * __restrict x_line  = x  + index;
			
				float prev_x = x_line[0];
			
                for (int i = 1; i < N - 1; i++, index++)
                {
				#if 1
					const float curr_x = x_line[i];
					
                    x_line[i] =
						(
							x0_line[i] +
								a *
                            	(
									+ (prev_x             + x_line[i + step_x])
									+ (x_line[i - step_y] + x_line[i + step_y])
									+ (x_line[i - step_z] + x_line[i + step_z])
								)
						) * cRecip;
					
					prev_x = curr_x;
				#else
					// note : we keep this verion around since it's easier to port to a shader
                    x[IX_3D(i, j, m)] =
						(x0[IX_3D(i, j, m)]
                            + a *
                            	(
									+ x[IX_3D(i+1, j  , m  )]
									+ x[IX_3D(i-1, j  , m  )]
									+ x[IX_3D(i  , j+1, m  )]
									+ x[IX_3D(i  , j-1, m  )]
									+ x[IX_3D(i  , j  , m+1)]
									+ x[IX_3D(i  , j  , m-1)]
								)
						) * cRecip;
				#endif
				}
            }
        }

        set_bnd3d(b, x, N);
    }
}

static void lin_solve3d_xyz(
	float * __restrict x, const float * __restrict x0,
	float * __restrict y, const float * __restrict y0,
	float * __restrict z, const float * __restrict z0,
	const float a, const float c, const int iter, const int N)
{
    float cRecip = 1.f / c;

    for (int k = 0; k < iter; k++)
    {
        for (int m = 1; m < N - 1; m++)
        {
            for (int j = 1; j < N - 1; j++)
            {
				int index = IX_3D(0, j, m);
				
            	const int step_x = 1;
            	const int step_y = N;
            	const int step_z = N * N;
				
				const float * __restrict x0_line = x0 + index;
					  float * __restrict x_line  = x  + index;
				
				const float * __restrict y0_line = y0 + index;
					  float * __restrict y_line  = y  + index;
				
				const float * __restrict z0_line = z0 + index;
					  float * __restrict z_line  = z  + index;
			
				float prev_x = x_line[0];
				float prev_y = y_line[0];
				float prev_z = z_line[0];
				
                for (int i = 1; i < N - 1; i++)
                {
					const float curr_x = x_line[i];
					const float curr_y = y_line[i];
					const float curr_z = z_line[i];
					
                   x_line[i] =
						(
							x0_line[i] +
								a *
                            	(
									+ (x_line[i + step_x] +             prev_x)
									+ (x_line[i + step_y] + x_line[i - step_y])
									+ (x_line[i + step_z] + x_line[i - step_z])
								)
						) * cRecip;
					
                    y_line[i] =
						(
							y0_line[i] +
								a *
                            	(
									+ (y_line[i + step_x] +             prev_y)
									+ (y_line[i + step_y] + y_line[i - step_y])
									+ (y_line[i + step_z] + y_line[i - step_z])
								)
						) * cRecip;
					
                    z_line[i] =
						(
							z0_line[i] +
								a *
                            	(
									+ (z_line[i + step_x] +             prev_z)
									+ (z_line[i + step_y] + z_line[i - step_y])
									+ (z_line[i + step_z] + z_line[i - step_z])
								)
						) * cRecip;
					
					prev_x = curr_x;
					prev_y = curr_y;
					prev_z = curr_z;
                }
            }
        }

        set_bnd3d(1, x, N);
        set_bnd3d(2, y, N);
        set_bnd3d(3, z, N);
    }
}

static void diffuse2d(const int b, float * x, const float * x0, const float diff, const float dt, const int iter, const int N)
{
	const float a = dt * diff * (N - 2);
	lin_solve2d(b, x, x0, a, 1 + 4 * a, iter, N);
}

static void diffuse2d_xy(float * x, const float * x0, float * y, const float * y0, const float diff, const float dt, const int iter, const int N)
{
	const float a = dt * diff * (N - 2);
	lin_solve2d_xy(x, x0, y, y0, a, 1 + 4 * a, iter, N);
}

static void diffuse3d(const int b, float * x, const float * x0, const float diff, const float dt, const int iter, const int N)
{
	const float a = dt * diff * (N - 2) * (N - 2);
	lin_solve3d(b, x, x0, a, 1 + 6 * a, iter, N);
}

static void diffuse3d_xyz(
	float * x, const float * x0,
	float * y, const float * y0,
	float * z, const float * z0,
	const float diff, const float dt, const int iter, const int N)
{
	const float a = dt * diff * (N - 2) * (N - 2);
	lin_solve3d_xyz(x, x0, y, y0, z, z0, a, 1 + 6 * a, iter, N);
}

static void project2d(
	float * __restrict velocX,
	float * __restrict velocY,
	float * __restrict p,
	float * __restrict div, const int iter, const int N)
{
	for (int j = 1; j < N - 1; ++j)
	{
		for (int i = 1; i < N - 1; ++i)
		{
			div[IX_2D(i, j)] =
				-0.25f *
					(
						+ (+ velocX[IX_2D(i+1, j  )] - velocX[IX_2D(i-1, j  )])
						+ (+ velocY[IX_2D(i  , j+1)] - velocY[IX_2D(i  , j-1)])
					);
		}
	}
	
    set_bnd2d(0, div, N);
	
    memset(p, 0, N * N * sizeof(float));
	lin_solve2d(0, p, div, 1, 4, iter, N);
	
	for (int j = 1; j < N - 1; ++j)
	{
		for (int i = 1; i < N - 1; ++i)
		{
			velocX[IX_2D(i, j)] -= ( p[IX_2D(i+1, j)] - p[IX_2D(i-1, j)] );
			velocY[IX_2D(i, j)] -= ( p[IX_2D(i, j+1)] - p[IX_2D(i, j-1)] );
		}
	}

    set_bnd2d(1, velocX, N);
    set_bnd2d(2, velocY, N);
}

static void project3d(
	float * __restrict velocX,
	float * __restrict velocY,
	float * __restrict velocZ,
	float * __restrict p,
	float * __restrict div,
	const int iter, const int N)
{
    for (int k = 1; k < N - 1; k++)
    {
        for (int j = 1; j < N - 1; j++)
        {
        	int index = IX_3D(1, j, k);
			
        	const int step_x = 1;
        	const int step_y = N;
        	const int step_z = N * N;
			
            for (int i = 1; i < N - 1; i++, index++)
            {
                div[index] =
                	-0.25f *
						(
							+ velocX[index + step_x] - velocX[index - step_x]
							+ velocY[index + step_y] - velocY[index - step_y]
							+ velocZ[index + step_z] - velocZ[index - step_z]
                    	);
            }
        }
    }
	
    set_bnd3d(0, div, N);
	
    memset(p, 0, N * N * N * sizeof(float));
    lin_solve3d(0, p, div, 1, 6, iter, N);
	
    for (int k = 1; k < N - 1; k++)
    {
        for (int j = 1; j < N - 1; j++)
        {
        	int index = IX_3D(1, j, k);
			
        	const int step_x = 1;
        	const int step_y = N;
        	const int step_z = N * N;
			
            for (int i = 1; i < N - 1; i++, index++)
            {
                velocX[index] -= ( p[index + step_x] - p[index - step_x] );
                velocY[index] -= ( p[index + step_y] - p[index - step_y] );
                velocZ[index] -= ( p[index + step_z] - p[index - step_z] );
            }
        }
    }
	
    set_bnd3d(1, velocX, N);
    set_bnd3d(2, velocY, N);
    set_bnd3d(3, velocZ, N);
}

static void advect2d(const int b, float * d, const float * d0, const float * velocX, const float * velocY, const float dt, const int N)
{
    const float dtx = dt * (N - 2);
    const float dty = dt * (N - 2);
	
	const float XY_max = N - 1.5f;
	
    float ifloat, jfloat;
    int i, j;
	
	for (j = 1, jfloat = 1; j < N - 1; ++j, ++jfloat)
	{
		for (i = 1, ifloat = 1; i < N - 1; ++i, ++ifloat)
		{
			const float tmp1 = dtx * velocX[IX_2D(i, j)];
			const float tmp2 = dty * velocY[IX_2D(i, j)];
			
			float x = ifloat - tmp1;
			float y = jfloat - tmp2;
			
			if(x < 0.5f) x = 0.5f;
			if(x > XY_max) x = XY_max;
			float i0, i1;
			i0 = floorf(x);
			i1 = i0 + 1.0f;
			
			if(y < 0.5f) y = 0.5f;
			if(y > XY_max) y = XY_max;
			float j0, j1;
			j0 = floorf(y);
			j1 = j0 + 1.0f;
			
			float s0, s1, t0, t1;
			s1 = x - i0;
			s0 = 1.0f - s1;
			t1 = y - j0;
			t0 = 1.0f - t1;
			
			const int i0i = i0;
			const int i1i = i1;
			const int j0i = j0;
			const int j1i = j1;
			
			//Assert(i0i >= 0 && i0i < N);
			//Assert(i1i >= 0 && i1i < N);
			//Assert(j0i >= 0 && j0i < N);
			//Assert(j1i >= 0 && j1i < N);
			
			d[IX_2D(i, j)] =
				s0 * (t0 * d0[IX_2D(i0i, j0i)] + t1 * d0[IX_2D(i0i, j1i)]) +
				s1 * (t0 * d0[IX_2D(i1i, j0i)] + t1 * d0[IX_2D(i1i, j1i)]);
		}
	}
	
    set_bnd2d(b, d, N);
}

static void advect3d(const int b, float * __restrict d, const float * __restrict d0, const float * velocX, const float * velocY, const float * velocZ, const float dt, const int N)
{
    float i0, i1, j0, j1, k0, k1;
    
    float dtx = dt * (N - 2);
    float dty = dt * (N - 2);
    float dtz = dt * (N - 2);
    
    float s0, s1, t0, t1, u0, u1;
    
    float Nfloat = N;
    float ifloat, jfloat, kfloat;
    int i, j, k;
	
    for (k = 1, kfloat = 1; k < N - 1; k++, kfloat++)
    {
        for (j = 1, jfloat = 1; j < N - 1; j++, jfloat++)
        {
            for (i = 1, ifloat = 1; i < N - 1; i++, ifloat++)
            {
                const float tmp1 = dtx * velocX[IX_3D(i, j, k)];
                const float tmp2 = dty * velocY[IX_3D(i, j, k)];
                const float tmp3 = dtz * velocZ[IX_3D(i, j, k)];
				
                float x = ifloat - tmp1;
                float y = jfloat - tmp2;
                float z = kfloat - tmp3;
				
                if(x < 0.5f) x = 0.5f; 
                if(x > Nfloat - 1.5f) x = Nfloat - 1.5f;
                i0 = floorf(x); 
                i1 = i0 + 1.0f;
				
                if(y < 0.5f) y = 0.5f; 
                if(y > Nfloat - 1.5f) y = Nfloat - 1.5f;
                j0 = floorf(y);
                j1 = j0 + 1.0f;
				
                if(z < 0.5f) z = 0.5f;
                if(z > Nfloat - 1.5f) z = Nfloat - 1.5f;
                k0 = floorf(z);
                k1 = k0 + 1.0f;
				
                s1 = x - i0; 
                s0 = 1.0f - s1; 
                t1 = y - j0; 
                t0 = 1.0f - t1;
                u1 = z - k0;
                u0 = 1.0f - u1;
				
                int i0i = i0;
                int i1i = i1;
                int j0i = j0;
                int j1i = j1;
                int k0i = k0;
                int k1i = k1;
				
				/*
                Assert(i0i >= 0 && i0i < N);
				Assert(i1i >= 0 && i1i < N);
				Assert(j0i >= 0 && j0i < N);
				Assert(j1i >= 0 && j1i < N);
				Assert(k0i >= 0 && k0i < N);
				Assert(k1i >= 0 && k1i < N);
				*/
				
                d[IX_3D(i, j, k)] =
					+ s0 *
						+ ( t0 * (u0 * d0[IX_3D(i0i, j0i, k0i)] + u1 * d0[IX_3D(i0i, j0i, k1i)])
                        + ( t1 * (u0 * d0[IX_3D(i0i, j1i, k0i)] + u1 * d0[IX_3D(i0i, j1i, k1i)])))
					+ s1 *
						+ ( t0 * (u0 * d0[IX_3D(i1i, j0i, k0i)] + u1 * d0[IX_3D(i1i, j0i, k1i)])
                        + ( t1 * (u0 * d0[IX_3D(i1i, j1i, k0i)] + u1 * d0[IX_3D(i1i, j1i, k1i)])));
            }
        }
    }
	
    set_bnd3d(b, d, N);
}

static void advect3d_xyz(
	float * __restrict _x, const float * __restrict x0,
	float * __restrict _y, const float * __restrict y0,
	float * __restrict _z, const float * __restrict z0,
	const float * velocX, const float * velocY, const float * velocZ, const float dt, const int N)
{
    float i0, i1, j0, j1, k0, k1;
	
    float dtx = dt * (N - 2);
    float dty = dt * (N - 2);
    float dtz = dt * (N - 2);
	
    float s0, s1, t0, t1, u0, u1;
	
    float Nfloat = N;
    float ifloat, jfloat, kfloat;
    int i, j, k;
	
    for (k = 1, kfloat = 1; k < N - 1; k++, kfloat++)
    {
        for (j = 1, jfloat = 1; j < N - 1; j++, jfloat++)
        {
            for (i = 1, ifloat = 1; i < N - 1; i++, ifloat++)
            {
            	const int index = IX_3D(i, j, k);
				
                const float tmp1 = dtx * velocX[index];
                const float tmp2 = dty * velocY[index];
                const float tmp3 = dtz * velocZ[index];
				
                float x = ifloat - tmp1;
                float y = jfloat - tmp2;
                float z = kfloat - tmp3;
				
                if(x < 0.5f) x = 0.5f;
                if(x > Nfloat - 1.5f) x = Nfloat - 1.5f;
                i0 = floorf(x);
                i1 = i0 + 1.0f;
				
                if(y < 0.5f) y = 0.5f;
                if(y > Nfloat - 1.5f) y = Nfloat - 1.5f;
                j0 = floorf(y);
                j1 = j0 + 1.0f;
				
                if(z < 0.5f) z = 0.5f;
                if(z > Nfloat - 1.5f) z = Nfloat - 1.5f;
                k0 = floorf(z);
                k1 = k0 + 1.0f;
				
                s1 = x - i0;
                s0 = 1.0f - s1;
                t1 = y - j0;
                t0 = 1.0f - t1;
                u1 = z - k0;
                u0 = 1.0f - u1;
				
                int i0i = i0;
                int i1i = i1;
                int j0i = j0;
                int j1i = j1;
                int k0i = k0;
                int k1i = k1;
				
				/*
                Assert(i0i >= 0 && i0i < N);
				Assert(i1i >= 0 && i1i < N);
				Assert(j0i >= 0 && j0i < N);
				Assert(j1i >= 0 && j1i < N);
				Assert(k0i >= 0 && k0i < N);
				Assert(k1i >= 0 && k1i < N);
				*/
				
				const int i000 = IX_3D(i0i, j0i, k0i);
				const int i010 = IX_3D(i0i, j1i, k0i);
				const int i001 = IX_3D(i0i, j0i, k1i);
				const int i011 = IX_3D(i0i, j1i, k1i);
				
				const int i100 = IX_3D(i1i, j0i, k0i);
				const int i101 = IX_3D(i1i, j0i, k1i);
				const int i110 = IX_3D(i1i, j1i, k0i);
				const int i111 = IX_3D(i1i, j1i, k1i);
				
                _x[index] =
					+ s0 *
						+ ( t0 * (u0 * x0[i000] + u1 * x0[i001])
                        + ( t1 * (u0 * x0[i010] + u1 * x0[i011])))
					+ s1 *
						+ ( t0 * (u0 * x0[i100] + u1 * x0[i101])
                        + ( t1 * (u0 * x0[i110] + u1 * x0[i111])));
				
				_y[index] =
					+ s0 *
						+ ( t0 * (u0 * y0[i000] + u1 * y0[i001])
                        + ( t1 * (u0 * y0[i010] + u1 * y0[i011])))
					+ s1 *
						+ ( t0 * (u0 * y0[i100] + u1 * y0[i101])
                        + ( t1 * (u0 * y0[i110] + u1 * y0[i111])));
				
				_z[index] =
					+ s0 *
						+ ( t0 * (u0 * z0[i000] + u1 * z0[i001])
                        + ( t1 * (u0 * z0[i010] + u1 * z0[i011])))
					+ s1 *
						+ ( t0 * (u0 * z0[i100] + u1 * z0[i101])
                        + ( t1 * (u0 * z0[i110] + u1 * z0[i111])));
            }
        }
    }
	
    set_bnd3d(1, _x, N);
    set_bnd3d(2, _y, N);
    set_bnd3d(3, _z, N);
}

struct FluidCube2d
{
	int size;

	float dt;
	float diff; // diffusion amount
	float visc; // viscosity

	std::vector<float> s;
	std::vector<float> density;

	std::vector<float> Vx;
	std::vector<float> Vy;

	std::vector<float> Vx0;
	std::vector<float> Vy0;

	void addDensity(const int x, const int y, const float amount)
	{
		if (x < 0 || x >= size ||
			y < 0 || y >= size)
		{
			return;
		}
		
		const int N = size;
		const int index = IX_2D(x, y);
		
		density[index] += amount;
	}
	
	void addVelocity(const int x, const int y, const float amountX, const float amountY)
	{
		if (x < 0 || x >= size ||
			y < 0 || y >= size)
		{
			return;
		}
		
		const int N = size;
		const int index = IX_2D(x, y);

		Vx[index] += amountX;
		Vy[index] += amountY;
	}

	void step()
	{
	    const int N = size;
		
	    const int iter = 4;
	
		diffuse2d_xy(Vx0.data(), Vx.data(), Vy0.data(), Vy.data(), visc, dt, iter, N);
		
		project2d(Vx0.data(), Vy0.data(), Vx.data(), Vy.data(), iter, N);
		
		advect2d(1, Vx.data(), Vx0.data(), Vx0.data(), Vy0.data(), dt, N);
	    advect2d(2, Vy.data(), Vy0.data(), Vx0.data(), Vy0.data(), dt, N);
		
		project2d(Vx.data(), Vy.data(), Vx0.data(), Vy0.data(), iter, N);
		
		diffuse2d(0, s.data(), density.data(), diff, dt, iter, N);
		
		advect2d(0, density.data(), s.data(), Vx.data(), Vy.data(), dt, N);
	}
};

struct FluidCube3d
{
	int size;

	float dt;
	float diff; // diffusion amount
	float visc; // viscosity

	std::vector<float> s;
	std::vector<float> density;

	std::vector<float> Vx;
	std::vector<float> Vy;
	std::vector<float> Vz;

	std::vector<float> Vx0;
	std::vector<float> Vy0;
	std::vector<float> Vz0;

	void addDensity(const int x, const int y, const int z, const float amount)
	{
		if (x < 0 || x >= size ||
			y < 0 || y >= size ||
			z < 0 || z >= size)
		{
			return;
		}
		
		const int N = size;
		const int index = IX_3D(x, y, z);
		
		density[index] += amount;
	}
	
	void addVelocity(const int x, const int y, const int z, const float amountX, const float amountY, const float amountZ)
	{
		if (x < 0 || x >= size ||
			y < 0 || y >= size ||
			z < 0 || z >= size)
		{
			return;
		}
		
		const int N = size;
		const int index = IX_3D(x, y, z);

		Vx[index] += amountX;
		Vy[index] += amountY;
		Vz[index] += amountZ;
	}

	void step()
	{
	    const int N = size;
		
	    const int iter = 4;
	
		diffuse3d_xyz(Vx0.data(), Vx.data(), Vy0.data(), Vy.data(), Vz0.data(), Vz.data(), visc, dt, iter, N);
		
		project3d(Vx0.data(), Vy0.data(), Vz0.data(), Vx.data(), Vy.data(), iter, N);
		
		advect3d_xyz(
			Vx.data(), Vx0.data(),
			Vy.data(), Vy0.data(),
			Vz.data(), Vz0.data(),
			Vx0.data(), Vy0.data(), Vz0.data(), dt, N);
	
		project3d(Vx.data(), Vy.data(), Vz.data(), Vx0.data(), Vy0.data(), iter, N);
		
		diffuse3d(0, s.data(), density.data(), diff, dt, iter, N);
		
	    advect3d(0, density.data(), s.data(), Vx.data(), Vy.data(), Vz.data(), dt, N);
	}
};

FluidCube2d * createFluidCube2d(const int size, const float diffusion, const float viscosity, const float dt)
{
	FluidCube2d * cube = new FluidCube2d();

	cube->size = size;
	cube->dt = dt;
	cube->diff = diffusion;
	cube->visc = viscosity;

	//const int N = size * size * size;
	const int N = size * size;

	cube->s.resize(N, 0.f);
	cube->density.resize(N, 0.f);

	cube->Vx.resize(N, 0.f);
	cube->Vy.resize(N, 0.f);

	cube->Vx0.resize(N, 0.f);
	cube->Vy0.resize(N, 0.f);

	return cube;
}

FluidCube3d * createFluidCube3d(const int size, const float diffusion, const float viscosity, const float dt)
{
	FluidCube3d * cube = new FluidCube3d();

	cube->size = size;
	cube->dt = dt;
	cube->diff = diffusion;
	cube->visc = viscosity;

	const int N = size * size * size;

	cube->s.resize(N, 0.f);
	cube->density.resize(N, 0.f);

	cube->Vx.resize(N, 0.f);
	cube->Vy.resize(N, 0.f);
	cube->Vz.resize(N, 0.f);

	cube->Vx0.resize(N, 0.f);
	cube->Vy0.resize(N, 0.f);
	cube->Vz0.resize(N, 0.f);

	return cube;
}

int main(int argc, char * argv[])
{
	setupPaths(CHIBI_RESOURCE_PATHS);
	
	if (!framework.init(600, 600))
		return -1;

#if THREE_DIMENSIONAL
	FluidCube3d * cube = createFluidCube3d(50, 0.0001f, 0.0001f, 1.f / 30.f);
#else
	FluidCube2d * cube = createFluidCube2d(300, 0.001f, 0.0001f, 1.f / 30.f);
#endif

	GxTexture texture;
	texture.allocate(cube->size, cube->size, GX_R32_FLOAT, true, true);
	texture.setSwizzle(0, 0, 0, GX_SWIZZLE_ONE);
	
	mouse.showCursor(false);
	
	for (;;)
	{
		framework.process();

		if (framework.quitRequested)
			break;

		for (auto & d : cube->density)
			d *= .99f;
		
	#if THREE_DIMENSIONAL
		const int z = cube->size/2 + cos(framework.time / 1.23f) * cube->size/3.f;
		cube->addDensity(mouse.x / 8, mouse.y / 8, z, 100.f);
		cube->addVelocity(mouse.x / 8, mouse.y / 8, z, mouse.dx, mouse.dy, cosf(framework.time) * 20.f);
	#else
		for (int x = -4; x <= +4; ++x)
		{
			for (int y = -4; y <= +4; ++y)
			{
				cube->addDensity(mouse.x / SCALE + x, mouse.y / SCALE + y, .1f);
				cube->addVelocity(mouse.x / SCALE, mouse.y / SCALE, mouse.dx / 100.f, mouse.dy / 100.f);
			}
		}
	#endif
		
		const auto t1 = g_TimerRT.TimeUS_get();
		
		cube->step();
		
		const auto t2 = g_TimerRT.TimeUS_get();
		
		//printf("step duration: %gms\n", (t2 - t1) / 1000.f);
		
	#if THREE_DIMENSIONAL
		framework.beginDraw(0, 0, 0, 0);
		{
			projectPerspective3d(60.f, .01f, 100.f);
			gxTranslatef(0, 0, 2);
			gxRotatef(framework.time * 10.f, 0, 1, 0);
			
			setBlend(BLEND_ADD);
			setColor(colorWhite);
			setAlphaf(.4f);
			
			for (int z = 0; z < cube->size; ++z)
			{
				gxPushMatrix();
				gxTranslatef(0, 0, lerp<float>(-.5f, +.5f, z / float(cube->size - 1)));
				const int N = cube->size;
				texture.upload(cube->density.data() + IX_3D(0, 0, z), 4, 0);
				
				gxSetTexture(texture.id);
				drawRect(-.5f, -.5f, .5f, .5f);
				gxSetTexture(0);
				gxPopMatrix();
			}
			
			lineCube(Vec3(), Vec3(.5f, .5f, .5f));
		}
		framework.endDraw();
	#else
		framework.beginDraw(255, 255, 255, 0);
		{
			gxScalef(SCALE, SCALE, 1);
			
			texture.upload(cube->density.data(), 4, 0);
			gxSetTexture(texture.id);
			setColorClamp(false);
			setColor(2000, 2000, 2000);
			drawRect(0, 0, cube->size, cube->size);
			setColorClamp(true);
			gxSetTexture(0);
			
			pushBlend(BLEND_ADD);
			hqBegin(HQ_LINES);
			{
				setColor(30, 20, 10);
				
				for (int y = 0; y < cube->size; y += 4)
				{
					const int N = cube->size;
					
					for (int x = 0; x < cube->size; x += 4)
					{
						const float vx = cube->Vx[IX_2D(x, y)];
						const float vy = cube->Vy[IX_2D(x, y)];
						
						hqLine(x, y, 1.f, x + vx * 300.f, y + vy * 300.f, 1.f);
					}
				}
			}
			hqEnd();
			popBlend();
		}
		framework.endDraw();
	#endif
	}
	
	texture.free();

	delete cube;
	cube = nullptr;

	framework.shutdown();
	
	return 0;
}
