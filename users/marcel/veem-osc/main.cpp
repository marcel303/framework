#include "framework.h"
#include "Log.h"
#include "StringEx.h"
#include "Timer.h"
#include "tinyxml2.h"
#include "tinyxml2_helpers.h"
#include <algorithm>
#include <atomic>
#include <cmath>

// for inbound OSC messages
#include "osc/OscPacketListener.h"

// for outbound OSC messages
#include "ip/UdpSocket.h"
#include "osc/OscOutboundPacketStream.h"

#define OSC_BUFFER_SIZE 2048

const int GFX_SX = 1000;
const int GFX_SY = 700;

std::atomic<bool> s_quitRequested(false);

static SDL_mutex * s_mutex = nullptr;

#define UPDATE_SLOW_INTERVAL 1000
#define REPAINT_INTERVAL 500
#define SEND_FAKE_SENSOR_DATA_INTERVAL 1000

// OSC address settings

struct OscAddressSettings
{
	struct Elem
	{
		std::string address;
		float smoothness = .5f;
		
		void init(const char * _address)
		{
			address = _address;
		}
	};
	
	std::map<std::string, Elem> elems;
	
	void saveXml(tinyxml2::XMLPrinter & p) const
	{
		for (auto & elemItr : elems)
		{
			auto & elem = elemItr.second;
		
			p.OpenElement("elem");
			{
				p.PushAttribute("address", elem.address.c_str());
				p.PushAttribute("smoothness", elem.smoothness);
			}
			p.CloseElement();
		}
	}
	
	void loadXml(const tinyxml2::XMLElement * e)
	{
		elems.clear();
		
		//
		
		for (const tinyxml2::XMLElement * elemXml = e->FirstChildElement("elem"); elemXml != nullptr; elemXml = elemXml->NextSiblingElement("elem"))
		{
			Elem elem;
			
			elem.address = stringAttrib(elemXml, "address", "");
			elem.smoothness = floatAttrib(elemXml, "smoothness", elem.smoothness);
			
			if (elem.address.empty())
				continue;
			
			elems[elem.address] = elem;
		}
	}
	
	Elem & getElem(const char * address)
	{
		auto elemItr = elems.find(address);
		
		if (elemItr == elems.end())
		{
			auto & elem = elems[address];
			
			elem.init(address);
			
			return elem;
		}
		else
		{
			return elemItr->second;
		}
	}
};

static OscAddressSettings s_oscAddressSettings;

// OSC message history

struct OscMessageHistory
{
	struct Elem
	{
		std::string address;
		std::vector<float> values;
		std::vector<float> values_slow;
		std::vector<float> values_gradient;
		std::vector<float> values_gradient_previousValues; // value of 'values' last time gradient was calculated
		uint64_t lastReceiveTime = 0;
		bool isAutoGenerated = false;
		bool isSigned = false;
		
		int recordCount = 0;
		
		void init(const char * _address)
		{
			address = _address;
			
			if (String::EndsWith(address, "_slow"))
				isAutoGenerated = true;
			
			if (String::EndsWith(address, "_gradient"))
			{
				isAutoGenerated = true;
				isSigned = true;
			}
		}
		
		void record(const std::vector<float> & _values)
		{
			values = _values;
			
			recordCount++;
		}
		
		void updateSlow(const float smoothness, const float dt)
		{
			// make sure the arrays have the correct size
			
			values_slow.resize(values.size(), 0.f);
			
			// update
			
			const float retain = std::pow(smoothness, dt / 60.f);
			
			for (size_t i = 0; i < values.size(); ++i)
			{
				const float oldValue = values_slow[i];
				const float newValue = values[i];
				
				values_slow[i] = oldValue * retain + newValue * (1.f - retain);
			}
		}
		
		void calculateGradient(const float dt)
		{
			// make sure the arrays have the correct size
			
			values_gradient.resize(values_slow.size(), 0.f);
			values_gradient_previousValues.resize(values_slow.size(), 0.f);
			
			for (size_t i = 0; i < values_slow.size(); ++i)
			{
				const float oldValue = values_gradient_previousValues[i];
				const float newValue = values_slow[i];
				
				const float delta = newValue - oldValue;
				const float changePerSecond = delta / dt;
				
				values_gradient[i] = changePerSecond;
			}
			
			values_gradient_previousValues = values_slow;
		}
	};
	
	std::map<std::string, Elem> elems;
	
	Elem & getElem(const char * address)
	{
		auto elemItr = elems.find(address);
		
		if (elemItr == elems.end())
		{
			auto & elem = elems[address];
			
			elem.init(address);
			
			return elem;
		}
		else
		{
			return elemItr->second;
		}
	}
	
	void eraseElem(const char * address)
	{
		auto elemItr = elems.find(address);
		
		if (elemItr != elems.end())
		{
			elems.erase(elemItr);
		}
	}
};

static OscMessageHistory s_oscMessageHistory;

// OSC receiver

struct OscPacketListener : osc::OscPacketListener
{
	virtual void ProcessMessage(const osc::ReceivedMessage & m, const IpEndpointName & remoteEndpoint) override
	{
		SDL_LockMutex(s_mutex);
		{
			// check address
			
			const char * address = m.AddressPattern();
			
			if (address != nullptr)
			{
				// record value
				
				OscMessageHistory::Elem & elem = s_oscMessageHistory.getElem(address);
				
				std::vector<float> values;
				
				for (auto aItr = m.ArgumentsBegin(); aItr != m.ArgumentsEnd(); ++aItr)
				{
					auto & a = *aItr;
					
					const float value = a.IsFloat() ? a.AsFloat() : 0.f;
					
					values.push_back(value);
				}
				
				elem.record(values);
			}
		}
		SDL_UnlockMutex(s_mutex);
	}
};

// IpEndpointName::ANY_ADDRESS

struct OscReceiver
{
	OscPacketListener * packetListener = nullptr;
	UdpListeningReceiveSocket * receiveSocket = nullptr;
	
	SDL_Thread * receiveThread = nullptr;
	
	~OscReceiver()
	{
		shut();
	}
	
	void init(const uint32_t ipAddress, const int udpPort)
	{
		packetListener = new OscPacketListener();
	
		receiveSocket = new UdpListeningReceiveSocket(IpEndpointName(ipAddress, udpPort), packetListener);
		
		receiveThread = SDL_CreateThread(receiveThreadProc, "OSC Receive", this);
	}
	
	void shut()
	{
		LOG_DBG("terminating OSC receive thread", 0);
		
		if (receiveSocket != nullptr)
		{
			receiveSocket->AsynchronousBreak();
		}
		
		if (receiveThread != nullptr)
		{
			SDL_WaitThread(receiveThread, nullptr);
			receiveThread = nullptr;
		}
		
		LOG_DBG("terminating OSC receive thread [done]", 0);
		
		LOG_DBG("terminating OSC UDP receive socket", 0);
		
		delete receiveSocket;
		receiveSocket = nullptr;
		
		LOG_DBG("terminating OSC UDP receive socket [done]", 0);
		
		delete packetListener;
		packetListener = nullptr;
	}
	
	static int receiveThreadProc(void * obj)
	{
		OscReceiver * self = (OscReceiver*)obj;
		
		self->receiveSocket->Run();
		
		return 0;
	}
};

//

struct OscSender
{
	UdpSocket * transmitSocket;
	IpEndpointName remoteEndpoint;
	
	void init(const char * ipAddress, const int udpPort)
	{
		transmitSocket = new UdpSocket();
		transmitSocket->SetEnableBroadcast(true);
		transmitSocket->SetAllowReuse(true);
		transmitSocket->Bind(IpEndpointName(IpEndpointName::ANY_ADDRESS, IpEndpointName::ANY_PORT));
		
		remoteEndpoint = IpEndpointName(ipAddress, udpPort);
	}
	
	void shut()
	{
		if (transmitSocket != nullptr)
		{
			delete transmitSocket;
			transmitSocket = nullptr;
		}
	}
	
	void send(const void * data, const int dataSize)
	{
		if (transmitSocket != nullptr)
		{
			transmitSocket->SendTo(remoteEndpoint, (char*)data, dataSize);
		}
	}
};

// event timer

struct EventTimer
{
	int event = -1;
	int interval = 0;
	SDL_Thread * thread = nullptr;
	std::atomic<bool> stop;
	
	EventTimer()
		: stop(false)
	{
	}
	
	~EventTimer()
	{
		shut();
	}
	
	void init(const int _event, const int _interval)
	{
		event = _event;
		interval = _interval;
		
		thread = SDL_CreateThread(timerThreadProc, "Event Timer", this);
	}
	
	void shut()
	{
		stop = true;
		
		SDL_WaitThread(thread, nullptr);
		thread = nullptr;
	}
	
	static int timerThreadProc(void * obj)
	{
		EventTimer * self = (EventTimer*)obj;
		
		while (self->stop == false)
		{
			SDL_Delay(self->interval);
			
			SDL_Event e;
			e.type = self->event;
			SDL_PushEvent(&e);
		}
		
		return 0;
	}
};

// slow-changing value update thread

static void updateSlow(OscSender & sender, const float dt)
{
	for (auto & elemItr : s_oscMessageHistory.elems)
	{
		auto & elem = elemItr.second;
		
		if (elem.isAutoGenerated)
			continue;
		
		// update slow-changing value
		
		auto & addressSettings = s_oscAddressSettings.getElem(elem.address.c_str());
		
		elem.updateSlow(addressSettings.smoothness, dt);
		
		// send slow-changing value
		
		{
			char address[256];
			sprintf_s(address, sizeof(address), "%s_slow", elem.address.c_str());
			
			char buffer[OSC_BUFFER_SIZE];
			osc::OutboundPacketStream p(buffer, OSC_BUFFER_SIZE);
			
			p << osc::BeginMessage(address);
			{
				for (auto & value : elem.values_slow)
					p << value;
			}
			p << osc::EndMessage;
			
			sender.send(p.Data(), p.Size());
		}
	}
}

static void updateGradient(OscSender & sender, const float dt)
{
	for (auto & elemItr : s_oscMessageHistory.elems)
	{
		auto & elem = elemItr.second;
		
		if (elem.isAutoGenerated)
			continue;
		
		// calculate gradient
		
		elem.calculateGradient(dt);
	
		// send gradient
		
		{
			char address[256];
			sprintf_s(address, sizeof(address), "%s_gradient", elem.address.c_str());
			
			char buffer[OSC_BUFFER_SIZE];
			osc::OutboundPacketStream p(buffer, OSC_BUFFER_SIZE);
			
			p << osc::BeginMessage(address);
			{
				for (auto & value : elem.values_gradient)
					p << value;
			}
			p << osc::EndMessage;
			
			sender.send(p.Data(), p.Size());
		}
	}
}

static int updateSlowThreadProc(void * obj)
{
	OscSender * sender = (OscSender*)obj;
	
	while (!s_quitRequested)
	{
		SDL_LockMutex(s_mutex);
		{
			const float dt = UPDATE_SLOW_INTERVAL / 1000.f;
			
			updateSlow(*sender, dt);
			
			updateGradient(*sender, dt);
		}
		SDL_UnlockMutex(s_mutex);
		
		SDL_Delay(UPDATE_SLOW_INTERVAL);
	}
	
	return 0;
}

static SDL_Thread * s_updateSlowThread = nullptr;

//

#include "Noise.h"

static bool s_sendFakeDataEnabled = false;

static void sendFakeCamera(OscSender & sender, const float rateOfChange, const char * addressPrefix)
{
	const int sx = 16;
	const int sy = 12;
	
	float values[sy][sx];
	
	float total = 0.f;
	
	for (int y = 0; y < sy; ++y)
	{
		for (int x = 0; x < sx; ++x)
		{
			const float value = scaled_octave_noise_3d(8, .6f, .1f, 0.f, 1.f, x, y, framework.time * rateOfChange);
			
			values[y][x] = value;
			
			total += value;
		}
	}
	
	const float average = total / (sx * sy);
	
	char buffer[OSC_BUFFER_SIZE];
	osc::OutboundPacketStream p(buffer, OSC_BUFFER_SIZE);
	p << osc::BeginBundleImmediate;
	{
		char rawAddress[256];
		sprintf_s(rawAddress, sizeof(rawAddress), "%s/raw", addressPrefix);
		p << osc::BeginMessage(rawAddress);
		for (int y = 0; y < sy; ++y)
			for (int x = 0; x < sx; ++x)
				p << values[y][x];
		p << osc::EndMessage;
		
		char averageAddress[256];
		sprintf_s(averageAddress, sizeof(averageAddress), "%s/average", addressPrefix);
		p << osc::BeginMessage(averageAddress);
		p << average;
		p << osc::EndMessage;
	}
	p << osc::EndBundle;

	sender.send(p.Data(), p.Size());
}

static int sendFakeSensorDataThreadProc(void * obj)
{
	OscSender * sender = (OscSender*)obj;
	
	uint64_t dropletTimer1 = 0;
	uint64_t dropletTimer2 = 0;
	int dropletCount = 0;
	
	while (!s_quitRequested)
	{
		if (s_sendFakeDataEnabled)
		{
			const float magnetX = scaled_octave_noise_1d(4, .6f, .1f, +.6f, +1.f, framework.time / 1.23f);
			const float magnetY = scaled_octave_noise_1d(4, .6f, .1f, -.4f, +.3f, framework.time / 1.45f);
			const float magnetZ = scaled_octave_noise_1d(4, .6f, .1f, -.2f, +.1f, framework.time / 1.67f);
			
			const float magnetStrength = std::min(1.f, std::sqrt(magnetX * magnetX + magnetY * magnetY + magnetZ * magnetZ));
			
			auto timeMS = g_TimerRT.TimeMS_get();
			
			if (timeMS >= dropletTimer1)
			{
				dropletTimer1 = timeMS + 20 * 1000;
				dropletTimer2 = 0;
				dropletCount = 3;
			}
			
			const bool doDroplet = dropletCount > 0 && timeMS >= dropletTimer2;
			
			if (doDroplet)
			{
				dropletTimer2 = timeMS + 3 * 1000;
				dropletCount--;
				
			}
			
			SDL_LockMutex(s_mutex);
			{
				char buffer[OSC_BUFFER_SIZE];
				osc::OutboundPacketStream p(buffer, OSC_BUFFER_SIZE);
				p << osc::BeginBundleImmediate;
				{
					p << osc::BeginMessage("/humidity");
					p << float(std::sin(framework.time * 2.0 * M_PI / 60.0) + 1.f) / 2.f;
					p << osc::EndMessage;
					
					p << osc::BeginMessage("/magnet/raw");
					p << magnetX;
					p << magnetY;
					p << magnetZ;
					p << osc::EndMessage;
					
					p << osc::BeginMessage("/magnet/strength");
					p << magnetStrength;
					p << osc::EndMessage;
					
					p << osc::BeginMessage("/bluetooth/count");
					p << float(int(framework.time / 6.f) % 6);
					p << osc::EndMessage;
					
					p << osc::BeginMessage("/veem/wind");
					p << lerp(2.f, 20.f, float(1.f - (std::cos(framework.time / 100.f) + 1.f) / 2.f));
					p << osc::EndMessage;
					
					p << osc::BeginMessage("/sound/intensity");
					p << (std::sin(framework.time / 10.f) + 1.f) / 2.f;
					p << osc::EndMessage;
					
					if (doDroplet)
					{
						p << osc::BeginMessage("/sound/droplet");
						p << random(-8.f, +8.f);
						p << random(-8.f, +8.f);
						p << osc::EndMessage;
					}
				}
				p << osc::EndBundle;
				
				sender->send(p.Data(), p.Size());
				
				//
				
				sendFakeCamera(*sender, .1f, "/env/light");
				
				sendFakeCamera(*sender, 1.f, "/room/light");
			}
			SDL_UnlockMutex(s_mutex);
		}
		else
		{
			dropletTimer1 = 0;
			dropletTimer2 = 0;
			dropletCount = 0;
		}
		
		SDL_Delay(SEND_FAKE_SENSOR_DATA_INTERVAL);
	}
	
	return 0;
}

static SDL_Thread * s_sendFakeSensorDataThread = nullptr;

//

static int drawValueGrid(const std::vector<float> & values, const int gridSx, const int gridSy, const bool isSigned)
{
	Assert(gridSx * gridSy == values.size());
	
	const int kScale = 6;
	
	gxPushMatrix();
	gxScalef(kScale, kScale, 0);
	hqBegin(HQ_FILLED_RECTS);
	{
		setColor(0, 0, 0, 200);
		hqFillRect(0, 0, gridSx, gridSy);
		setAlpha(255);
	}
	hqEnd();
	gxTranslatef(.5f, .5f, 0);
	hqBegin(HQ_FILLED_CIRCLES);
	{
		for (int y = 0; y < gridSy; ++y)
		{
			for (int x = 0; x < gridSx; ++x)
			{
				const int index = x + y * gridSx;
				
				const float value = (index < values.size()) ? values[index] : 0.f;
				
				if (isSigned)
					//setLumif(std::abs(value));
					setLumif((value + 1.f) / 2.f);
				else
					setLumif(value);
				
				hqFillCircle(x, y, .4f);
			}
		}
	}
	hqEnd();
	gxPopMatrix();
	
	return gridSy * kScale;
}

int main(int argc, char * argv[])
{
#if defined(CHIBI_RESOURCE_PATH)
	changeDirectory(CHIBI_RESOURCE_PATH);
#else
	const char * basePath = SDL_GetBasePath();
	changeDirectory(basePath);
#endif
	
	const int kFontSize = 14;
	
	if (!framework.init(GFX_SX, GFX_SY))
		return -1;
	
	// load OSC settings
	
	{
		tinyxml2::XMLDocument d;
		if (d.LoadFile("veem-osc.xml") == tinyxml2::XML_SUCCESS)
		{
			tinyxml2::XMLElement * settingsXml = d.FirstChildElement("settings");
			
			if (settingsXml != nullptr)
			{
				tinyxml2::XMLElement * addressSettingsXml = settingsXml->FirstChildElement("addressSettings");
				
				if (addressSettingsXml != nullptr)
				{
					s_oscAddressSettings.loadXml(addressSettingsXml);
				}
			}
		}
	}
	
	s_mutex = SDL_CreateMutex();
	
	OscReceiver * receiver = new OscReceiver();
	receiver->init(IpEndpointName::ANY_ADDRESS, 8000);
	
	OscSender * sender = new OscSender();
	sender->init("255.255.255.255", 8000);
	
	const int repaintEvent = SDL_RegisterEvents(1);
	
	EventTimer * repaintTimer = new EventTimer();
	repaintTimer->init(repaintEvent, REPAINT_INTERVAL);
	
	s_updateSlowThread = SDL_CreateThread(updateSlowThreadProc, "Update Slow", sender);
	
	s_sendFakeSensorDataThread = SDL_CreateThread(sendFakeSensorDataThreadProc, "Send Fake Sensor Data", sender);
	
	bool continousRepaint = false;
	
	for (;;)
	{
		framework.waitForEvents = !continousRepaint;
		
		framework.process();
		
		if (keyboard.wentDown(SDLK_ESCAPE))
			framework.quitRequested = true;
		
		if (framework.quitRequested)
			break;
		
		bool repaint = false;
		
		//if (continousRepaint)
			repaint = true;
		
		for (auto & event : framework.events)
		{
			if (event.type == repaintEvent)
			{
				repaint = true;
			}
		}
		
		if (keyboard.wentDown(SDLK_f))
		{
			s_sendFakeDataEnabled = !s_sendFakeDataEnabled;
		}
		
		if (keyboard.wentDown(SDLK_p))
		{
			continousRepaint = !continousRepaint;
		}
		
		if (repaint)
		{
			OscAddressSettings addressSettings;
			OscMessageHistory history;
			
			SDL_LockMutex(s_mutex);
			{
				addressSettings = s_oscAddressSettings;
				
				history = s_oscMessageHistory;
			}
			SDL_UnlockMutex(s_mutex);
			
			framework.beginDraw(200, 200, 200, 0);
			{
				setFont("calibri.ttf");
				pushFontMode(FONT_SDF);
				
				gxPushMatrix();
				{
					setColor(colorWhite);
					setLumi(40);
					
					drawText(5, 5, kFontSize, +1, +1, "F = change send fake sensor data (%s), P = change power-save (%s)",
						s_sendFakeDataEnabled ? "enable" : "disabled",
						continousRepaint ? "disabled" : "enabled");
					
					const int yBegin = 5 + 24;
					
					int x = 10;
					int y = yBegin;
					
					for (auto & elemItr : history.elems)
					{
						auto & elem = elemItr.second;
						
						int sy = 16;
						
						gxPushMatrix();
						{
							gxTranslatef(x, y, 0);
							
							if (y == yBegin)
							{
								setLumi(180);
								drawLine(-5, 0, -5, (GFX_SY - 100)*2/3);
							}
							
							// smoothness control
							
							if (elem.isAutoGenerated == false)
							{
								auto & settingsElem = addressSettings.getElem(elem.address.c_str());
								
								const int smoothSx = 20;
								const int smoothSy = sy - 4;
								
								const int smoothX1 = x;
								const int smoothY1 = y;
								const int smoothX2 = smoothX1 + smoothSx;
								const int smoothY2 = smoothY1 + smoothSy;
								
								const bool hoverSmooth =
									mouse.x >= smoothX1 && mouse.x <= smoothX2 &&
									mouse.y >= smoothY1 && mouse.y <= smoothY2;
								
								setLumi(255);
								drawRect(smoothX1 - x, smoothY1 - y, smoothX1 - x + smoothSx * settingsElem.smoothness, smoothY2 - y);
								setLumi(160);
								drawRectLine(smoothX1 - x, smoothY1 - y, smoothX2 - x, smoothY2 - y);
								
								setLumi(40);
								drawText(
									(smoothX1 + smoothX2) / 2.f - x,
									(smoothY1 + smoothY2) / 2.f - y,
									10, 0, 0, "%d", int(std::round(settingsElem.smoothness * 100.f)));
								
								if (hoverSmooth)
								{
									if (mouse.isDown(BUTTON_LEFT))
									{
										SDL_LockMutex(s_mutex);
										{
											auto & realSettingsElem = s_oscAddressSettings.getElem(settingsElem.address.c_str());
											
											const float t = (mouse.x - smoothX1) / float(smoothSx);
										
											realSettingsElem.smoothness = saturate(t);
										}
										SDL_UnlockMutex(s_mutex);
									}
								}
							}
							
							// highlight and erase
							
							if (elem.isAutoGenerated == false)
							{
								const int elemSx = 190;
								const int elemSy = sy - 4;
								
								const int elemX1 = x + 24;
								const int elemY1 = y;
								const int elemX2 = elemX1 + elemSx;
								const int elemY2 = elemY1 + elemSy;
								
								const bool hoverElem =
									mouse.x >= elemX1 && mouse.x <= elemX2 &&
									mouse.y >= elemY1 && mouse.y <= elemY2;
								
								if (hoverElem)
								{
									setLumi(160);
									drawRect(elemX1 - x, elemY1 - y, elemX2 - x, elemY2 - y);
									
									if (mouse.wentDown(BUTTON_RIGHT))
									{
										SDL_LockMutex(s_mutex);
										{
											auto elemItr = s_oscMessageHistory.elems.find(elem.address.c_str());
											
											if (elemItr != s_oscMessageHistory.elems.end())
											{
												auto & elem = elemItr->second;
												
												char slowAddress[256];
												sprintf_s(slowAddress, sizeof(slowAddress), "%s_slow", elem.address.c_str());
												
												char gradientAddress[256];
												sprintf_s(gradientAddress, sizeof(gradientAddress), "%s_gradient", elem.address.c_str());
												
												s_oscMessageHistory.eraseElem(elem.address.c_str());
												
												s_oscMessageHistory.eraseElem(slowAddress);
												s_oscMessageHistory.eraseElem(gradientAddress);
											}
										}
										SDL_UnlockMutex(s_mutex);
									}
								}
							}
							
							gxTranslatef(24, 0, 0);
							
							setLumi(40);
							
							drawText(0, 0, kFontSize, +1, +1, "%s", elem.address.c_str());
							gxTranslatef(200, 0, 0);
							
							if (elem.isAutoGenerated)
							{
								drawText(0, 0, kFontSize, +1, +1, "Sent");
								gxTranslatef(60, 0, 0);
								drawText(0, 0, kFontSize, +1, +1, "x %d", elem.recordCount);
								gxTranslatef(80, 0, 0);
							}
							else
							{
								drawText(0, 0, kFontSize, +1, +1, "Received");
								gxTranslatef(60, 0, 0);
								drawText(0, 0, kFontSize, +1, +1, "x %d", elem.recordCount);
								gxTranslatef(80, 0, 0);
							}
							
							if (elem.values.size() > 1)
							{
								if (elem.values.size() == 16 * 12)
								{
									// this is a camera feed!
									
									const int gridSy = drawValueGrid(elem.values, 16, 12, elem.isSigned);
									
									sy = std::max(sy, gridSy + 4);
								}
								else
								{
									const int gridSy = drawValueGrid(elem.values, elem.values.size(), 1, elem.isSigned);
									
									sy = std::max(sy, gridSy + 4);
								}
							}
							else
							{
								for (auto & value : elem.values)
								{
									drawText(0, 0, kFontSize, +1, +1, "%.2f", value);
									gxTranslatef(32, 0, 0);
								}
							}
						}
						gxPopMatrix();
						
						y += sy;
						
						if (y >= GFX_SY - 100)
						{
							x += 480;
							y = yBegin;
						}
					}
				}
				gxPopMatrix();
				
				popFontMode();
			}
			framework.endDraw();
		}
	}
	
	// save OSC settings
	
	{
		tinyxml2::XMLPrinter p;
		p.OpenElement("settings");
		{
			p.OpenElement("addressSettings");
			{
				SDL_LockMutex(s_mutex);
				{
					s_oscAddressSettings.saveXml(p);
				}
				SDL_UnlockMutex(s_mutex);
			}
			p.CloseElement();
		}
		p.CloseElement();
		
		tinyxml2::XMLDocument d;
		if (d.Parse(p.CStr()) == tinyxml2::XML_SUCCESS)
			d.SaveFile("veem-osc.xml");
	}
	
	// quit the app
	
	s_quitRequested = true;
	
	SDL_WaitThread(s_sendFakeSensorDataThread, nullptr);
	
	SDL_WaitThread(s_updateSlowThread, nullptr);
	
	delete repaintTimer;
	repaintTimer = nullptr;
	
	delete receiver;
	receiver = nullptr;
	
	SDL_DestroyMutex(s_mutex);
	s_mutex = nullptr;
	
	Font("calibri.ttf").saveCache();
	
	framework.shutdown();
	
	return 0;
}
