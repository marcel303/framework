include renderOne/light-functions.txt

float computeAttenuationForPointLight(
	vec3 surfacePosition,
	vec3 lightPosition,
	float lightRadius)
{
	vec3 lightToSurface = surfacePosition - lightPosition;

	float distanceSquared = dot(lightToSurface, lightToSurface);

	float lightRadiusSquared = lightRadius * lightRadius;

	if (distanceSquared == 0.0 || distanceSquared >= lightRadiusSquared)
	{
		return 0.0;
	}
	else
	{
		float attenuation = caculateInverseSquareWithWindowingFunction(
			distanceSquared,
			lightRadiusSquared);

		return attenuation;
	}
}

float computeAttenuationForSpotLight(
	vec3 surfacePosition,
	vec3 spotPosition,
	vec3 spotDirection,
	float spotAngleAlpha, // cos(spotAngle/2)
	float lightRadius)
{
	float distance =
		dot(surfacePosition, spotDirection) -
		dot(spotPosition, spotDirection);

	if (distance <= 0.0 || distance >= lightRadius)
	{
		return 0.0;
	}
	else
	{
		vec3 lightToSurface = surfacePosition - spotPosition;

		float cosAngle = dot(spotDirection, normalize(lightToSurface));

		float attenuation = max(0.0, cosAngle - spotAngleAlpha) / (1.0 - spotAngleAlpha);

		float distanceSquared = distance * distance;

		float lightRadiusSquared = lightRadius * lightRadius;

		attenuation *= caculateInverseSquareWithWindowingFunction(
			distanceSquared,
			lightRadiusSquared);

		return attenuation;
	}
}
