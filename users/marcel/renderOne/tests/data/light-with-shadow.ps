include engine/ShaderPS.txt

uniform sampler2D shadowDepthAtlas;
uniform sampler2D shadowColorAtlas;

uniform mat4x4 shadowMatrices[32];

shader_in vec3 v_position;
shader_in vec2 v_texcoord;

vec3 lookupShadow(int id, vec3 position_view)
{
	float enableColorShadows = 0.0;
	float numMaps = 4.0;

	if (id >= numMaps)
		return vec3(1.0);

	vec4 position_light = shadowMatrices[id] * vec4(position_view, 1.0);

	vec2 position_texture = position_light.xy / position_light.w;

#if 1
	if (position_texture.x < -1.0 || position_texture.x > +1.0)
		return vec3(0.0);
	if (position_texture.y < -1.0 || position_texture.y > +1.0)
		return vec3(0.0);
#endif

	position_texture = (position_texture + vec2(1.0)) * 0.5;

	vec2 atlas_p1 = vec2(1.0 / numMaps * (id + 0), 0.0);
	vec2 atlas_p2 = vec2(1.0 / numMaps * (id + 1), 1.0);

	vec2 atlas_coord = mix(atlas_p1, atlas_p2, position_texture);

	//atlas_coord += 0.5 / textureSize(shadowDepthAtlas, 0);

	//atlas_coord = max(atlas_p1, min(atlas_p2, atlas_coord)); // when offsetting like for PCF, this would be necessary

	//atlas_coord.x += 0.1;

	float depth = texture(shadowDepthAtlas, atlas_coord).x;

	//if (position_light.z < 0.0) return vec3(1, 0, 1);
	//if (depth < 0.0) return vec3(0, 0, 1);
	//if (depth > 1000.0) return vec3(1, 0, 0);

#if 0
	if (atlas_coord.x < atlas_p1.x || atlas_coord.x > atlas_p2.x)
		return vec3(1, 0, 0);
	if (atlas_coord.y < atlas_p1.y || atlas_coord.y > atlas_p2.y)
		return vec3(0, 0, 1);
#endif

#if 0
	if (position_texture.x < 0.0 || position_texture.x > 1.0)
		return vec3(1, 0, 0);
	if (position_texture.y < 0.0 || position_texture.y > 1.0)
		return vec3(0, 0, 1);
#endif

	//return vec3(atlas_p1, 0);
	//return vec3(atlas_p2, 0);
	//return vec3(atlas_coord, 0.0);
	//return vec3(depth);
	//return v_position;

	//return vec3(position_texture, 0.0);
	//return vec3(0.5);
	//return position_light.zzz;
	//return vec3(abs(position_light.z - depth));

	if (depth < position_light.z)
		//return vec3(0.5, 0, 0.5);
		//return mix(vec3(1.0), vec3(0.1, 0.0, 0.1), clamp(position_light.z - depth, 0.0, 1.0));
		return vec3(0.0);
	else if (enableColorShadows != 0.0)
		return texture(shadowColorAtlas, atlas_coord).rgb;
	else
		return vec3(1.0);
}

vec3 calculateLight(int id, vec3 position_view)
{
	vec4 position_light = shadowMatrices[id] * vec4(position_view, 1.0);

	vec3 result = lookupShadow(id, position_view);

	result *= 10.0;

	//float att = max(0.0, 1.0 - dot(position_light.xy, position_light.xy));
	float att = 1.0;
	float distance_falloff = 1.0 / (position_light.z * position_light.z);

	result *= att * distance_falloff;

	return result;
}

void main()
{
	vec3 color = vec3(0.0);

	color += vec3(1, 1, 0) * calculateLight(0, v_position);
	color += vec3(0, 1, 1) * calculateLight(1, v_position);
	color += vec3(1, 0, 1) * calculateLight(2, v_position);

	color /= 3.0;
	color += vec3(0.01);

	color = pow(color, vec3(1.0/2.2));

	shader_fragColor = vec4(color, 1.0);
}
