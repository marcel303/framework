include renderOne/forward-lighting/light-params.txt
include renderOne/forward-lighting/light-volume.txt
include renderOne/shadow-mapping/shadow-mapping.txt

#define DEBUG_LIGHTING_COMPLXITY 0

vec3 calculateLight(int id, vec3 position_view, bool receiveShadows)
{
	vec4 position_light = shadowMatrices[id] * vec4(position_view, 1.0);

	if (position_light.z < 0.0)
		return vec3(0.0);

	vec3 result = vec3(1.0);

	if (receiveShadows)
	{
		result *= lookupShadow(id, position_view);
	}

	float distance_attenuation = 1.0 / (position_light.z * position_light.z);

	position_light.xy /= position_light.w;
	float spot_attenuation = max(0.0, 1.0 - dot(position_light.xy, position_light.xy));
	//float spot_attenuation = 1.0;

	result *= spot_attenuation * distance_attenuation;

	return result;
}

vec3 s_position_view;
vec3 s_color;
bool s_receiveShadows;

#if DEBUG_LIGHTING_COMPLXITY
int s_numLights;
#endif

void forEachLightId(int id)
{
	LightParams light = lookupLightParams(id);
		
	int shadowMapId = int(light.userData);

	s_color += light.color * calculateLight(shadowMapId, s_position_view, s_receiveShadows && shadowMapId != -1);

#if DEBUG_LIGHTING_COMPLXITY
	s_numLights++;
#endif
}

vec3 calculateLighting(vec3 position_view, bool receiveShadows)
{
	// -- use light volume to lookup lights at view-position --

	s_position_view = position_view;
	s_color = vec3(0.0);
	s_receiveShadows = receiveShadows;

#if DEBUG_LIGHTING_COMPLXITY
	s_numLights = 0;
#endif

	forEachLightIdAt(position_view);

	// -- add ambient light --

	s_color += vec3(0.01);

	// -- apply debugs --

#if DEBUG_LIGHTING_COMPLXITY
	s_color += vec3(s_numLights / 16.0);
#endif

	return s_color;
}
