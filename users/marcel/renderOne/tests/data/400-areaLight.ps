include engine/ShaderPS.txt
include engine/ShaderUtil.txt

uniform mat4x4 worldToLight;
uniform mat4x4 lightToWorld;

#if 0
//uniform mat4x4 lightToWorld_rotation;
//uniform vec3 lightToWorld_translation;
//uniform vec3 lightToWorld_scale;
#else
uniform mat4x4 lightToWorld_packed;

#define lightToWorld_rotation lightToWorld_packed
#define lightToWorld_translation lightToWorld_packed[3].xyz
#define lightToWorld_scale vec3(lightToWorld_packed[0][3], lightToWorld_packed[1][3], lightToWorld_packed[2][3])
#endif

uniform float alternate;

shader_in vec3 v_position;
shader_in vec3 v_normal;

vec3 nearestPointOnBox(vec3 surfacePosition)
{
	vec3 lightToSurface = surfacePosition;

	vec3 movement = max(vec3(-1.0), min(vec3(+1.0), lightToSurface));

	return movement;
}

vec3 nearestPointOnSphere(vec3 surfacePosition)
{
	vec3 lightToSurface = surfacePosition;
	
	float distance = length(lightToSurface);
	
	float movementAmount = min(1.0, distance);
	
	vec3 movement = lightToSurface / distance * movementAmount;

	return movement;
}

void main()
{
	vec3 lightPosition = vec3(0.0);

	vec3 position_world = v_position;
	vec3 position_light;

	if (alternate != 1.0)
	{
		position_light = (worldToLight * vec4(position_world, 1.0)).xyz;
	}
	else
	{
		position_light = position_world;
		position_light -= lightToWorld_translation;
		position_light = (transpose(lightToWorld_rotation) * vec4(position_light, 0.0)).xyz;
		position_light /= lightToWorld_scale;
	}

	vec3 nearestPosition = nearestPointOnBox(position_light);
	//vec3 nearestPosition = nearestPointOnSphere(position_light);

	float attenuation;

	if (alternate == 0.0)
	{
		// perform distance attenuation, dot product in light-space, by applying scaling factors to revert light-space scaling

		vec3 surfaceToLight = nearestPosition - position_light;

	// two options for attenuation and normal:
		// 1. transform light-space position back to view-space (or world-space)
			// requires extra uniform: mat4x4 light-to-view
			// requires extra matrix multiply: position back to view-space
		// 2. perform calculations in light-space, and account for scaling with a separate uniform
			// requires extra uniform: scaling
			// requires extra matrix multiply: normal to light-space
		// back to view-space has the advantage that it integrates better into the rest of the system, which works within view-space, usually
	// third option ?
		// when rotation and scaling are stored separately, going back to view-space could
		// be performed using a scaling operation, and multiplication using the ortho-normal inverse of the (unscaled) view-to-light matrix

		float scaling_x = length((lightToWorld * vec4(1, 0, 0, 0)).xyz);
		float scaling_y = length((lightToWorld * vec4(0, 1, 0, 0)).xyz);
		float scaling_z = length((lightToWorld * vec4(0, 0, 1, 0)).xyz);
		vec3 scaling = vec3(scaling_x, scaling_y, scaling_z);

		surfaceToLight *= scaling;

		attenuation = 1.0 / dot(surfaceToLight, surfaceToLight);

		vec3 surfaceToLightDir = normalize(surfaceToLight);
		vec3 normal = (worldToLight * vec4(v_normal, 0.0)).xyz;
		normal *= scaling;
		normal = normalize(normal);
		attenuation *= max(0.001, dot(normal, surfaceToLightDir));
	}
	else if (alternate == 1.0)
	{
		// perform distance attenuation, dot product in world-space, by transforming the closest point back into world-space
		// == optimized to use only one mat4x4 shader uniform instead of two ==

		nearestPosition = (lightToWorld_rotation * vec4(nearestPosition * lightToWorld_scale, 0.0)).xyz + lightToWorld_translation;

		vec3 surfaceToLight = nearestPosition - v_position;

		attenuation = 1.0 / dot(surfaceToLight, surfaceToLight);

		vec3 surfaceToLightDir = normalize(surfaceToLight);
		vec3 normal = normalize(v_normal);
		attenuation *= max(0.001, dot(normal, surfaceToLightDir));
	}
	else
	{
		// perform distance attenuation, dot product in world-space, by transforming the closest point back into world-space

		nearestPosition = (lightToWorld * vec4(nearestPosition, 1.0)).xyz;

		vec3 surfaceToLight = nearestPosition - v_position;

		attenuation = 1.0 / dot(surfaceToLight, surfaceToLight);

		vec3 surfaceToLightDir = normalize(surfaceToLight);
		vec3 normal = normalize(v_normal);
		attenuation *= max(0.001, dot(normal, surfaceToLightDir));
	}

	//vec3 color = srgbToLinear(vec3(0.25, 0.5, 1.0)) * 0.02;
	//vec3 color = srgbToLinear(vec3(0.25, 0.5, 1.0)) * 0.5;
	vec3 color = srgbToLinear(vec3(0.25, 0.5, 1.0)) * 1.0;
	color *= attenuation;
	color = linearToSrgb(color);

	shader_fragColor = vec4(color, 1.0);
}
