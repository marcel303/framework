uniform sampler2D lightVolume;
uniform sampler2D lightIds;
uniform float worldToVolumeScale;

#if !defined(__METAL_VERSION__)
	void forEachLightId(int id);
#endif

ivec2 rOne_toIvec2(vec2 v)
{
	return ivec2(
		v.x,
		v.y);
}

void forEachLightIdAt(vec3 in_position)
{
	vec3 position = in_position * worldToVolumeScale;
	
	ivec2 lightVolumeDims = rOne_toIvec2(textureSize(lightVolume, 0));

	// position to cell coord

	int x = int(floor(position.x));
	int y = int(floor(position.y));
	int z = int(floor(position.z));

	x += (lightVolumeDims.x - 1) / 2;
	y += (lightVolumeDims.x - 1) / 2;
	z += (lightVolumeDims.x - 1) / 2;

	if (x < 0 || x >= lightVolumeDims.x ||
		y < 0 || y >= lightVolumeDims.x ||
		z < 0 || z >= lightVolumeDims.x) // note : this assumes the volume has NxNxN cells. perhaps make dimensions a uniform so we can have different dimensions for each axis
	{
		return;
	}

	ivec2 startOffsetAndCount = rOne_toIvec2(texelFetch(lightVolume, ivec2(x, y + z * lightVolumeDims.x), 0).xy);

	int startOffset = startOffsetAndCount.x;
	int count = startOffsetAndCount.y;

	ivec2 lightIdsDim = rOne_toIvec2(textureSize(lightIds, 0));

	for (int i = 0; i < count; ++i)
	{
		int index = startOffset + i;

		int u = index & 4095;
		int v = index >> 12;

		int id = int(texelFetch(lightIds, ivec2(u, v), 0));

		forEachLightId(id);
	}
}

